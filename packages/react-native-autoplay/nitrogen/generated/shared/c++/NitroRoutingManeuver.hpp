///
/// NitroRoutingManeuver.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `NitroAttributedString` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroAttributedString; }
// Forward declaration of `GlyphImage` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct GlyphImage; }
// Forward declaration of `AssetImage` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct AssetImage; }
// Forward declaration of `TurnType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class TurnType; }
// Forward declaration of `OffRampType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class OffRampType; }
// Forward declaration of `OnRampType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class OnRampType; }
// Forward declaration of `ForkType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class ForkType; }
// Forward declaration of `KeepType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class KeepType; }
// Forward declaration of `LaneGuidance` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct LaneGuidance; }
// Forward declaration of `NitroColor` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroColor; }
// Forward declaration of `TravelEstimates` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct TravelEstimates; }
// Forward declaration of `TrafficSide` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class TrafficSide; }
// Forward declaration of `ManeuverType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class ManeuverType; }

#include "NitroAttributedString.hpp"
#include <vector>
#include "GlyphImage.hpp"
#include "AssetImage.hpp"
#include <variant>
#include <optional>
#include "TurnType.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "ForkType.hpp"
#include "KeepType.hpp"
#include "LaneGuidance.hpp"
#include "NitroColor.hpp"
#include <string>
#include "TravelEstimates.hpp"
#include "TrafficSide.hpp"
#include "ManeuverType.hpp"

namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid {

  /**
   * A struct which can be represented as a JavaScript object (NitroRoutingManeuver).
   */
  struct NitroRoutingManeuver {
  public:
    std::vector<NitroAttributedString> attributedInstructionVariants     SWIFT_PRIVATE;
    std::variant<GlyphImage, AssetImage> symbolImage     SWIFT_PRIVATE;
    std::optional<std::variant<GlyphImage, AssetImage>> junctionImage     SWIFT_PRIVATE;
    std::optional<TurnType> turnType     SWIFT_PRIVATE;
    std::optional<double> angle     SWIFT_PRIVATE;
    std::optional<std::vector<double>> elementAngles     SWIFT_PRIVATE;
    std::optional<double> exitNumber     SWIFT_PRIVATE;
    std::optional<OffRampType> offRampType     SWIFT_PRIVATE;
    std::optional<OnRampType> onRampType     SWIFT_PRIVATE;
    std::optional<ForkType> forkType     SWIFT_PRIVATE;
    std::optional<KeepType> keepType     SWIFT_PRIVATE;
    std::optional<LaneGuidance> linkedLaneGuidance     SWIFT_PRIVATE;
    NitroColor cardBackgroundColor     SWIFT_PRIVATE;
    std::string id     SWIFT_PRIVATE;
    TravelEstimates travelEstimates     SWIFT_PRIVATE;
    TrafficSide trafficSide     SWIFT_PRIVATE;
    ManeuverType maneuverType     SWIFT_PRIVATE;
    std::optional<std::vector<std::string>> roadName     SWIFT_PRIVATE;
    std::optional<std::string> highwayExitLabel     SWIFT_PRIVATE;

  public:
    NitroRoutingManeuver() = default;
    explicit NitroRoutingManeuver(std::vector<NitroAttributedString> attributedInstructionVariants, std::variant<GlyphImage, AssetImage> symbolImage, std::optional<std::variant<GlyphImage, AssetImage>> junctionImage, std::optional<TurnType> turnType, std::optional<double> angle, std::optional<std::vector<double>> elementAngles, std::optional<double> exitNumber, std::optional<OffRampType> offRampType, std::optional<OnRampType> onRampType, std::optional<ForkType> forkType, std::optional<KeepType> keepType, std::optional<LaneGuidance> linkedLaneGuidance, NitroColor cardBackgroundColor, std::string id, TravelEstimates travelEstimates, TrafficSide trafficSide, ManeuverType maneuverType, std::optional<std::vector<std::string>> roadName, std::optional<std::string> highwayExitLabel): attributedInstructionVariants(attributedInstructionVariants), symbolImage(symbolImage), junctionImage(junctionImage), turnType(turnType), angle(angle), elementAngles(elementAngles), exitNumber(exitNumber), offRampType(offRampType), onRampType(onRampType), forkType(forkType), keepType(keepType), linkedLaneGuidance(linkedLaneGuidance), cardBackgroundColor(cardBackgroundColor), id(id), travelEstimates(travelEstimates), trafficSide(trafficSide), maneuverType(maneuverType), roadName(roadName), highwayExitLabel(highwayExitLabel) {}
  };

} // namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid

namespace margelo::nitro {

  // C++ NitroRoutingManeuver <> JS NitroRoutingManeuver (object)
  template <>
  struct JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroRoutingManeuver> final {
    static inline margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroRoutingManeuver fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroRoutingManeuver(
        JSIConverter<std::vector<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroAttributedString>>::fromJSI(runtime, obj.getProperty(runtime, "attributedInstructionVariants")),
        JSIConverter<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>::fromJSI(runtime, obj.getProperty(runtime, "symbolImage")),
        JSIConverter<std::optional<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>>::fromJSI(runtime, obj.getProperty(runtime, "junctionImage")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TurnType>>::fromJSI(runtime, obj.getProperty(runtime, "turnType")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "angle")),
        JSIConverter<std::optional<std::vector<double>>>::fromJSI(runtime, obj.getProperty(runtime, "elementAngles")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "exitNumber")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OffRampType>>::fromJSI(runtime, obj.getProperty(runtime, "offRampType")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OnRampType>>::fromJSI(runtime, obj.getProperty(runtime, "onRampType")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ForkType>>::fromJSI(runtime, obj.getProperty(runtime, "forkType")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::KeepType>>::fromJSI(runtime, obj.getProperty(runtime, "keepType")),
        JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::LaneGuidance>>::fromJSI(runtime, obj.getProperty(runtime, "linkedLaneGuidance")),
        JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroColor>::fromJSI(runtime, obj.getProperty(runtime, "cardBackgroundColor")),
        JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, "id")),
        JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TravelEstimates>::fromJSI(runtime, obj.getProperty(runtime, "travelEstimates")),
        JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TrafficSide>::fromJSI(runtime, obj.getProperty(runtime, "trafficSide")),
        JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ManeuverType>::fromJSI(runtime, obj.getProperty(runtime, "maneuverType")),
        JSIConverter<std::optional<std::vector<std::string>>>::fromJSI(runtime, obj.getProperty(runtime, "roadName")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "highwayExitLabel"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroRoutingManeuver& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "attributedInstructionVariants", JSIConverter<std::vector<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroAttributedString>>::toJSI(runtime, arg.attributedInstructionVariants));
      obj.setProperty(runtime, "symbolImage", JSIConverter<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>::toJSI(runtime, arg.symbolImage));
      obj.setProperty(runtime, "junctionImage", JSIConverter<std::optional<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>>::toJSI(runtime, arg.junctionImage));
      obj.setProperty(runtime, "turnType", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TurnType>>::toJSI(runtime, arg.turnType));
      obj.setProperty(runtime, "angle", JSIConverter<std::optional<double>>::toJSI(runtime, arg.angle));
      obj.setProperty(runtime, "elementAngles", JSIConverter<std::optional<std::vector<double>>>::toJSI(runtime, arg.elementAngles));
      obj.setProperty(runtime, "exitNumber", JSIConverter<std::optional<double>>::toJSI(runtime, arg.exitNumber));
      obj.setProperty(runtime, "offRampType", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OffRampType>>::toJSI(runtime, arg.offRampType));
      obj.setProperty(runtime, "onRampType", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OnRampType>>::toJSI(runtime, arg.onRampType));
      obj.setProperty(runtime, "forkType", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ForkType>>::toJSI(runtime, arg.forkType));
      obj.setProperty(runtime, "keepType", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::KeepType>>::toJSI(runtime, arg.keepType));
      obj.setProperty(runtime, "linkedLaneGuidance", JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::LaneGuidance>>::toJSI(runtime, arg.linkedLaneGuidance));
      obj.setProperty(runtime, "cardBackgroundColor", JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroColor>::toJSI(runtime, arg.cardBackgroundColor));
      obj.setProperty(runtime, "id", JSIConverter<std::string>::toJSI(runtime, arg.id));
      obj.setProperty(runtime, "travelEstimates", JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TravelEstimates>::toJSI(runtime, arg.travelEstimates));
      obj.setProperty(runtime, "trafficSide", JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TrafficSide>::toJSI(runtime, arg.trafficSide));
      obj.setProperty(runtime, "maneuverType", JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ManeuverType>::toJSI(runtime, arg.maneuverType));
      obj.setProperty(runtime, "roadName", JSIConverter<std::optional<std::vector<std::string>>>::toJSI(runtime, arg.roadName));
      obj.setProperty(runtime, "highwayExitLabel", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.highwayExitLabel));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::vector<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroAttributedString>>::canConvert(runtime, obj.getProperty(runtime, "attributedInstructionVariants"))) return false;
      if (!JSIConverter<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>::canConvert(runtime, obj.getProperty(runtime, "symbolImage"))) return false;
      if (!JSIConverter<std::optional<std::variant<margelo::nitro::at::g4rb4g3::autoplay::hybrid::GlyphImage, margelo::nitro::at::g4rb4g3::autoplay::hybrid::AssetImage>>>::canConvert(runtime, obj.getProperty(runtime, "junctionImage"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TurnType>>::canConvert(runtime, obj.getProperty(runtime, "turnType"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "angle"))) return false;
      if (!JSIConverter<std::optional<std::vector<double>>>::canConvert(runtime, obj.getProperty(runtime, "elementAngles"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "exitNumber"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OffRampType>>::canConvert(runtime, obj.getProperty(runtime, "offRampType"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::OnRampType>>::canConvert(runtime, obj.getProperty(runtime, "onRampType"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ForkType>>::canConvert(runtime, obj.getProperty(runtime, "forkType"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::KeepType>>::canConvert(runtime, obj.getProperty(runtime, "keepType"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::at::g4rb4g3::autoplay::hybrid::LaneGuidance>>::canConvert(runtime, obj.getProperty(runtime, "linkedLaneGuidance"))) return false;
      if (!JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::NitroColor>::canConvert(runtime, obj.getProperty(runtime, "cardBackgroundColor"))) return false;
      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, "id"))) return false;
      if (!JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TravelEstimates>::canConvert(runtime, obj.getProperty(runtime, "travelEstimates"))) return false;
      if (!JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::TrafficSide>::canConvert(runtime, obj.getProperty(runtime, "trafficSide"))) return false;
      if (!JSIConverter<margelo::nitro::at::g4rb4g3::autoplay::hybrid::ManeuverType>::canConvert(runtime, obj.getProperty(runtime, "maneuverType"))) return false;
      if (!JSIConverter<std::optional<std::vector<std::string>>>::canConvert(runtime, obj.getProperty(runtime, "roadName"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "highwayExitLabel"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
