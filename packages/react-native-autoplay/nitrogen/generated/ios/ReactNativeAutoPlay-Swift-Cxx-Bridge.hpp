///
/// ReactNativeAutoPlay-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AlertActionStyle` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class AlertActionStyle; }
// Forward declaration of `AlertDismissalReason` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class AlertDismissalReason; }
// Forward declaration of `AssetImage` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct AssetImage; }
// Forward declaration of `AutoText` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct AutoText; }
// Forward declaration of `ColorScheme` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class ColorScheme; }
// Forward declaration of `DistanceUnits` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class DistanceUnits; }
// Forward declaration of `Distance` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct Distance; }
// Forward declaration of `DurationWithTimeZone` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct DurationWithTimeZone; }
// Forward declaration of `ForkType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class ForkType; }
// Forward declaration of `GlyphImage` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct GlyphImage; }
// Forward declaration of `HybridAutoPlaySpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridAutoPlaySpec; }
// Forward declaration of `HybridCarPlayDashboardSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridCarPlayDashboardSpec; }
// Forward declaration of `HybridClusterSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridClusterSpec; }
// Forward declaration of `HybridGridTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridGridTemplateSpec; }
// Forward declaration of `HybridInformationTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridInformationTemplateSpec; }
// Forward declaration of `HybridListTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridListTemplateSpec; }
// Forward declaration of `HybridMapTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridMapTemplateSpec; }
// Forward declaration of `HybridMessageTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridMessageTemplateSpec; }
// Forward declaration of `HybridSearchTemplateSpec` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { class HybridSearchTemplateSpec; }
// Forward declaration of `ImageLane` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct ImageLane; }
// Forward declaration of `KeepType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class KeepType; }
// Forward declaration of `LaneGuidance` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct LaneGuidance; }
// Forward declaration of `ManeuverType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class ManeuverType; }
// Forward declaration of `NavigationAlertAction` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NavigationAlertAction; }
// Forward declaration of `NitroActionType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class NitroActionType; }
// Forward declaration of `NitroAction` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroAction; }
// Forward declaration of `NitroAlignment` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class NitroAlignment; }
// Forward declaration of `NitroAttributedStringImage` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroAttributedStringImage; }
// Forward declaration of `NitroAttributedString` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroAttributedString; }
// Forward declaration of `NitroBaseMapTemplateConfig` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroBaseMapTemplateConfig; }
// Forward declaration of `NitroButtonStyle` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class NitroButtonStyle; }
// Forward declaration of `NitroCarPlayDashboardButton` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroCarPlayDashboardButton; }
// Forward declaration of `NitroColor` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroColor; }
// Forward declaration of `NitroGridButton` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroGridButton; }
// Forward declaration of `NitroMapButtonType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class NitroMapButtonType; }
// Forward declaration of `NitroMapButton` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroMapButton; }
// Forward declaration of `NitroMessageManeuver` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroMessageManeuver; }
// Forward declaration of `NitroRoutingManeuver` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroRoutingManeuver; }
// Forward declaration of `NitroRow` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroRow; }
// Forward declaration of `NitroSectionType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class NitroSectionType; }
// Forward declaration of `NitroSection` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct NitroSection; }
// Forward declaration of `OffRampType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class OffRampType; }
// Forward declaration of `OnRampType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class OnRampType; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct Point; }
// Forward declaration of `PreferredImageLane` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct PreferredImageLane; }
// Forward declaration of `RouteChoice` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct RouteChoice; }
// Forward declaration of `SafeAreaInsets` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct SafeAreaInsets; }
// Forward declaration of `TrafficSide` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class TrafficSide; }
// Forward declaration of `TravelEstimates` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct TravelEstimates; }
// Forward declaration of `TripPoint` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct TripPoint; }
// Forward declaration of `TripSelectorCallback` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct TripSelectorCallback; }
// Forward declaration of `TripsConfig` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { struct TripsConfig; }
// Forward declaration of `TurnType` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class TurnType; }
// Forward declaration of `VisibilityState` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class VisibilityState; }
// Forward declaration of `VisibleTravelEstimate` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class VisibleTravelEstimate; }
// Forward declaration of `ZoomEvent` to properly resolve imports.
namespace margelo::nitro::swe::iternio::reactnativeautoplay { enum class ZoomEvent; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridAutoPlaySpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridAutoPlaySpec_cxx; }
// Forward declaration of `HybridCarPlayDashboardSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridCarPlayDashboardSpec_cxx; }
// Forward declaration of `HybridClusterSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridClusterSpec_cxx; }
// Forward declaration of `HybridGridTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridGridTemplateSpec_cxx; }
// Forward declaration of `HybridInformationTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridInformationTemplateSpec_cxx; }
// Forward declaration of `HybridListTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridListTemplateSpec_cxx; }
// Forward declaration of `HybridMapTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridMapTemplateSpec_cxx; }
// Forward declaration of `HybridMessageTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridMessageTemplateSpec_cxx; }
// Forward declaration of `HybridSearchTemplateSpec_cxx` to properly resolve imports.
namespace ReactNativeAutoPlay { class HybridSearchTemplateSpec_cxx; }

// Include C++ defined types
#include "AlertActionStyle.hpp"
#include "AlertDismissalReason.hpp"
#include "AssetImage.hpp"
#include "AutoText.hpp"
#include "ColorScheme.hpp"
#include "Distance.hpp"
#include "DistanceUnits.hpp"
#include "DurationWithTimeZone.hpp"
#include "ForkType.hpp"
#include "GlyphImage.hpp"
#include "HybridAutoPlaySpec.hpp"
#include "HybridCarPlayDashboardSpec.hpp"
#include "HybridClusterSpec.hpp"
#include "HybridGridTemplateSpec.hpp"
#include "HybridInformationTemplateSpec.hpp"
#include "HybridListTemplateSpec.hpp"
#include "HybridMapTemplateSpec.hpp"
#include "HybridMessageTemplateSpec.hpp"
#include "HybridSearchTemplateSpec.hpp"
#include "ImageLane.hpp"
#include "KeepType.hpp"
#include "LaneGuidance.hpp"
#include "ManeuverType.hpp"
#include "NavigationAlertAction.hpp"
#include "NitroAction.hpp"
#include "NitroActionType.hpp"
#include "NitroAlignment.hpp"
#include "NitroAttributedString.hpp"
#include "NitroAttributedStringImage.hpp"
#include "NitroBaseMapTemplateConfig.hpp"
#include "NitroButtonStyle.hpp"
#include "NitroCarPlayDashboardButton.hpp"
#include "NitroColor.hpp"
#include "NitroGridButton.hpp"
#include "NitroMapButton.hpp"
#include "NitroMapButtonType.hpp"
#include "NitroMessageManeuver.hpp"
#include "NitroRoutingManeuver.hpp"
#include "NitroRow.hpp"
#include "NitroSection.hpp"
#include "NitroSectionType.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "Point.hpp"
#include "PreferredImageLane.hpp"
#include "RouteChoice.hpp"
#include "SafeAreaInsets.hpp"
#include "TrafficSide.hpp"
#include "TravelEstimates.hpp"
#include "TripPoint.hpp"
#include "TripSelectorCallback.hpp"
#include "TripsConfig.hpp"
#include "TurnType.hpp"
#include "VisibilityState.hpp"
#include "VisibleTravelEstimate.hpp"
#include "ZoomEvent.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::swe::iternio::reactnativeautoplay::bridge::swift {

  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(VisibilityState /* payload */)>
  /**
   * Specialized version of `std::function<void(VisibilityState)>`.
   */
  using Func_void_VisibilityState = std::function<void(VisibilityState /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(VisibilityState / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_VisibilityState_Wrapper final {
  public:
    explicit Func_void_VisibilityState_Wrapper(std::function<void(VisibilityState /* payload */)>&& func): _function(std::make_unique<std::function<void(VisibilityState /* payload */)>>(std::move(func))) {}
    inline void call(int payload) const noexcept {
      _function->operator()(static_cast<VisibilityState>(payload));
    }
  private:
    std::unique_ptr<std::function<void(VisibilityState /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_VisibilityState create_Func_void_VisibilityState(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_VisibilityState_Wrapper wrap_Func_void_VisibilityState(Func_void_VisibilityState value) noexcept {
    return Func_void_VisibilityState_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() noexcept {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) noexcept {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const SafeAreaInsets& /* insets */)>
  /**
   * Specialized version of `std::function<void(const SafeAreaInsets&)>`.
   */
  using Func_void_SafeAreaInsets = std::function<void(const SafeAreaInsets& /* insets */)>;
  /**
   * Wrapper class for a `std::function<void(const SafeAreaInsets& / * insets * /)>`, this can be used from Swift.
   */
  class Func_void_SafeAreaInsets_Wrapper final {
  public:
    explicit Func_void_SafeAreaInsets_Wrapper(std::function<void(const SafeAreaInsets& /* insets */)>&& func): _function(std::make_unique<std::function<void(const SafeAreaInsets& /* insets */)>>(std::move(func))) {}
    inline void call(SafeAreaInsets insets) const noexcept {
      _function->operator()(insets);
    }
  private:
    std::unique_ptr<std::function<void(const SafeAreaInsets& /* insets */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_SafeAreaInsets create_Func_void_SafeAreaInsets(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_SafeAreaInsets_Wrapper wrap_Func_void_SafeAreaInsets(Func_void_SafeAreaInsets value) noexcept {
    return Func_void_SafeAreaInsets_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroColor>
  /**
   * Specialized version of `std::optional<NitroColor>`.
   */
  using std__optional_NitroColor_ = std::optional<NitroColor>;
  inline std::optional<NitroColor> create_std__optional_NitroColor_(const NitroColor& value) noexcept {
    return std::optional<NitroColor>(value);
  }
  inline bool has_value_std__optional_NitroColor_(const std::optional<NitroColor>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroColor get_std__optional_NitroColor_(const std::optional<NitroColor>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<GlyphImage, AssetImage>
  /**
   * Wrapper struct for `std::variant<GlyphImage, AssetImage>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_GlyphImage__AssetImage_ {
    std::variant<GlyphImage, AssetImage> variant;
    std__variant_GlyphImage__AssetImage_(std::variant<GlyphImage, AssetImage> variant): variant(variant) { }
    operator std::variant<GlyphImage, AssetImage>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline GlyphImage get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline AssetImage get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_GlyphImage__AssetImage_ create_std__variant_GlyphImage__AssetImage_(const GlyphImage& value) noexcept {
    return std__variant_GlyphImage__AssetImage_(value);
  }
  inline std__variant_GlyphImage__AssetImage_ create_std__variant_GlyphImage__AssetImage_(const AssetImage& value) noexcept {
    return std__variant_GlyphImage__AssetImage_(value);
  }
  
  // pragma MARK: std::optional<std::variant<GlyphImage, AssetImage>>
  /**
   * Specialized version of `std::optional<std::variant<GlyphImage, AssetImage>>`.
   */
  using std__optional_std__variant_GlyphImage__AssetImage__ = std::optional<std::variant<GlyphImage, AssetImage>>;
  inline std::optional<std::variant<GlyphImage, AssetImage>> create_std__optional_std__variant_GlyphImage__AssetImage__(const std::variant<GlyphImage, AssetImage>& value) noexcept {
    return std::optional<std::variant<GlyphImage, AssetImage>>(value);
  }
  inline bool has_value_std__optional_std__variant_GlyphImage__AssetImage__(const std::optional<std::variant<GlyphImage, AssetImage>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<GlyphImage, AssetImage> get_std__optional_std__variant_GlyphImage__AssetImage__(const std::optional<std::variant<GlyphImage, AssetImage>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAlignment>
  /**
   * Specialized version of `std::optional<NitroAlignment>`.
   */
  using std__optional_NitroAlignment_ = std::optional<NitroAlignment>;
  inline std::optional<NitroAlignment> create_std__optional_NitroAlignment_(const NitroAlignment& value) noexcept {
    return std::optional<NitroAlignment>(value);
  }
  inline bool has_value_std__optional_NitroAlignment_(const std::optional<NitroAlignment>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAlignment get_std__optional_NitroAlignment_(const std::optional<NitroAlignment>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroButtonStyle>
  /**
   * Specialized version of `std::optional<NitroButtonStyle>`.
   */
  using std__optional_NitroButtonStyle_ = std::optional<NitroButtonStyle>;
  inline std::optional<NitroButtonStyle> create_std__optional_NitroButtonStyle_(const NitroButtonStyle& value) noexcept {
    return std::optional<NitroButtonStyle>(value);
  }
  inline bool has_value_std__optional_NitroButtonStyle_(const std::optional<NitroButtonStyle>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroButtonStyle get_std__optional_NitroButtonStyle_(const std::optional<NitroButtonStyle>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroAction>
  /**
   * Specialized version of `std::vector<NitroAction>`.
   */
  using std__vector_NitroAction_ = std::vector<NitroAction>;
  inline std::vector<NitroAction> create_std__vector_NitroAction_(size_t size) noexcept {
    std::vector<NitroAction> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroAction>>
  /**
   * Specialized version of `std::optional<std::vector<NitroAction>>`.
   */
  using std__optional_std__vector_NitroAction__ = std::optional<std::vector<NitroAction>>;
  inline std::optional<std::vector<NitroAction>> create_std__optional_std__vector_NitroAction__(const std::vector<NitroAction>& value) noexcept {
    return std::optional<std::vector<NitroAction>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroAction__(const std::optional<std::vector<NitroAction>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroAction> get_std__optional_std__vector_NitroAction__(const std::optional<std::vector<NitroAction>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridAutoPlaySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridAutoPlaySpec>`.
   */
  using std__shared_ptr_HybridAutoPlaySpec_ = std::shared_ptr<HybridAutoPlaySpec>;
  std::shared_ptr<HybridAutoPlaySpec> create_std__shared_ptr_HybridAutoPlaySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridAutoPlaySpec_(std__shared_ptr_HybridAutoPlaySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridAutoPlaySpec>
  using std__weak_ptr_HybridAutoPlaySpec_ = std::weak_ptr<HybridAutoPlaySpec>;
  inline std__weak_ptr_HybridAutoPlaySpec_ weakify_std__shared_ptr_HybridAutoPlaySpec_(const std::shared_ptr<HybridAutoPlaySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::function<void()>>
  using Result_std__function_void____ = Result<std::function<void()>>;
  inline Result_std__function_void____ create_Result_std__function_void____(const std::function<void()>& value) noexcept {
    return Result<std::function<void()>>::withValue(value);
  }
  inline Result_std__function_void____ create_Result_std__function_void____(const std::exception_ptr& error) noexcept {
    return Result<std::function<void()>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) noexcept {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) noexcept {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<NitroCarPlayDashboardButton>
  /**
   * Specialized version of `std::vector<NitroCarPlayDashboardButton>`.
   */
  using std__vector_NitroCarPlayDashboardButton_ = std::vector<NitroCarPlayDashboardButton>;
  inline std::vector<NitroCarPlayDashboardButton> create_std__vector_NitroCarPlayDashboardButton_(size_t size) noexcept {
    std::vector<NitroCarPlayDashboardButton> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(ColorScheme /* payload */)>
  /**
   * Specialized version of `std::function<void(ColorScheme)>`.
   */
  using Func_void_ColorScheme = std::function<void(ColorScheme /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(ColorScheme / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_ColorScheme_Wrapper final {
  public:
    explicit Func_void_ColorScheme_Wrapper(std::function<void(ColorScheme /* payload */)>&& func): _function(std::make_unique<std::function<void(ColorScheme /* payload */)>>(std::move(func))) {}
    inline void call(int payload) const noexcept {
      _function->operator()(static_cast<ColorScheme>(payload));
    }
  private:
    std::unique_ptr<std::function<void(ColorScheme /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_ColorScheme create_Func_void_ColorScheme(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_ColorScheme_Wrapper wrap_Func_void_ColorScheme(Func_void_ColorScheme value) noexcept {
    return Func_void_ColorScheme_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridCarPlayDashboardSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridCarPlayDashboardSpec>`.
   */
  using std__shared_ptr_HybridCarPlayDashboardSpec_ = std::shared_ptr<HybridCarPlayDashboardSpec>;
  std::shared_ptr<HybridCarPlayDashboardSpec> create_std__shared_ptr_HybridCarPlayDashboardSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridCarPlayDashboardSpec_(std__shared_ptr_HybridCarPlayDashboardSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridCarPlayDashboardSpec>
  using std__weak_ptr_HybridCarPlayDashboardSpec_ = std::weak_ptr<HybridCarPlayDashboardSpec>;
  inline std__weak_ptr_HybridCarPlayDashboardSpec_ weakify_std__shared_ptr_HybridCarPlayDashboardSpec_(const std::shared_ptr<HybridCarPlayDashboardSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: std::function<void(const std::string& /* clusterId */)>
  /**
   * Specialized version of `std::function<void(const std::string&)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* clusterId */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * clusterId * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_Wrapper(std::function<void(const std::string& /* clusterId */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* clusterId */)>>(std::move(func))) {}
    inline void call(std::string clusterId) const noexcept {
      _function->operator()(clusterId);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* clusterId */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string create_Func_void_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_Wrapper wrap_Func_void_std__string(Func_void_std__string value) noexcept {
    return Func_void_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<NitroAttributedStringImage>
  /**
   * Specialized version of `std::vector<NitroAttributedStringImage>`.
   */
  using std__vector_NitroAttributedStringImage_ = std::vector<NitroAttributedStringImage>;
  inline std::vector<NitroAttributedStringImage> create_std__vector_NitroAttributedStringImage_(size_t size) noexcept {
    std::vector<NitroAttributedStringImage> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroAttributedStringImage>>
  /**
   * Specialized version of `std::optional<std::vector<NitroAttributedStringImage>>`.
   */
  using std__optional_std__vector_NitroAttributedStringImage__ = std::optional<std::vector<NitroAttributedStringImage>>;
  inline std::optional<std::vector<NitroAttributedStringImage>> create_std__optional_std__vector_NitroAttributedStringImage__(const std::vector<NitroAttributedStringImage>& value) noexcept {
    return std::optional<std::vector<NitroAttributedStringImage>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroAttributedStringImage__(const std::optional<std::vector<NitroAttributedStringImage>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroAttributedStringImage> get_std__optional_std__vector_NitroAttributedStringImage__(const std::optional<std::vector<NitroAttributedStringImage>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroAttributedString>
  /**
   * Specialized version of `std::vector<NitroAttributedString>`.
   */
  using std__vector_NitroAttributedString_ = std::vector<NitroAttributedString>;
  inline std::vector<NitroAttributedString> create_std__vector_NitroAttributedString_(size_t size) noexcept {
    std::vector<NitroAttributedString> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::string& /* clusterId */, ColorScheme /* payload */)>
  /**
   * Specialized version of `std::function<void(const std::string&, ColorScheme)>`.
   */
  using Func_void_std__string_ColorScheme = std::function<void(const std::string& /* clusterId */, ColorScheme /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * clusterId * /, ColorScheme / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_ColorScheme_Wrapper final {
  public:
    explicit Func_void_std__string_ColorScheme_Wrapper(std::function<void(const std::string& /* clusterId */, ColorScheme /* payload */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* clusterId */, ColorScheme /* payload */)>>(std::move(func))) {}
    inline void call(std::string clusterId, int payload) const noexcept {
      _function->operator()(clusterId, static_cast<ColorScheme>(payload));
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* clusterId */, ColorScheme /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_ColorScheme create_Func_void_std__string_ColorScheme(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_ColorScheme_Wrapper wrap_Func_void_std__string_ColorScheme(Func_void_std__string_ColorScheme value) noexcept {
    return Func_void_std__string_ColorScheme_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::string& /* clusterId */, ZoomEvent /* payload */)>
  /**
   * Specialized version of `std::function<void(const std::string&, ZoomEvent)>`.
   */
  using Func_void_std__string_ZoomEvent = std::function<void(const std::string& /* clusterId */, ZoomEvent /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * clusterId * /, ZoomEvent / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_ZoomEvent_Wrapper final {
  public:
    explicit Func_void_std__string_ZoomEvent_Wrapper(std::function<void(const std::string& /* clusterId */, ZoomEvent /* payload */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* clusterId */, ZoomEvent /* payload */)>>(std::move(func))) {}
    inline void call(std::string clusterId, int payload) const noexcept {
      _function->operator()(clusterId, static_cast<ZoomEvent>(payload));
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* clusterId */, ZoomEvent /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_ZoomEvent create_Func_void_std__string_ZoomEvent(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_ZoomEvent_Wrapper wrap_Func_void_std__string_ZoomEvent(Func_void_std__string_ZoomEvent value) noexcept {
    return Func_void_std__string_ZoomEvent_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::string& /* clusterId */, bool /* payload */)>
  /**
   * Specialized version of `std::function<void(const std::string&, bool)>`.
   */
  using Func_void_std__string_bool = std::function<void(const std::string& /* clusterId */, bool /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * clusterId * /, bool / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_bool_Wrapper final {
  public:
    explicit Func_void_std__string_bool_Wrapper(std::function<void(const std::string& /* clusterId */, bool /* payload */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* clusterId */, bool /* payload */)>>(std::move(func))) {}
    inline void call(std::string clusterId, bool payload) const noexcept {
      _function->operator()(clusterId, payload);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* clusterId */, bool /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_bool create_Func_void_std__string_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_bool_Wrapper wrap_Func_void_std__string_bool(Func_void_std__string_bool value) noexcept {
    return Func_void_std__string_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridClusterSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridClusterSpec>`.
   */
  using std__shared_ptr_HybridClusterSpec_ = std::shared_ptr<HybridClusterSpec>;
  std::shared_ptr<HybridClusterSpec> create_std__shared_ptr_HybridClusterSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridClusterSpec_(std__shared_ptr_HybridClusterSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridClusterSpec>
  using std__weak_ptr_HybridClusterSpec_ = std::weak_ptr<HybridClusterSpec>;
  inline std__weak_ptr_HybridClusterSpec_ weakify_std__shared_ptr_HybridClusterSpec_(const std::shared_ptr<HybridClusterSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::function<void(std::optional<bool> /* animated */)>
  /**
   * Specialized version of `std::function<void(std::optional<bool>)>`.
   */
  using Func_void_std__optional_bool_ = std::function<void(std::optional<bool> /* animated */)>;
  /**
   * Wrapper class for a `std::function<void(std::optional<bool> / * animated * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_bool__Wrapper final {
  public:
    explicit Func_void_std__optional_bool__Wrapper(std::function<void(std::optional<bool> /* animated */)>&& func): _function(std::make_unique<std::function<void(std::optional<bool> /* animated */)>>(std::move(func))) {}
    inline void call(std::optional<bool> animated) const noexcept {
      _function->operator()(animated);
    }
  private:
    std::unique_ptr<std::function<void(std::optional<bool> /* animated */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_bool_ create_Func_void_std__optional_bool_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_bool__Wrapper wrap_Func_void_std__optional_bool_(Func_void_std__optional_bool_ value) noexcept {
    return Func_void_std__optional_bool__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(std::optional<bool> /* animated */)>>
  /**
   * Specialized version of `std::optional<std::function<void(std::optional<bool> / * animated * /)>>`.
   */
  using std__optional_std__function_void_std__optional_bool_____animated______ = std::optional<std::function<void(std::optional<bool> /* animated */)>>;
  inline std::optional<std::function<void(std::optional<bool> /* animated */)>> create_std__optional_std__function_void_std__optional_bool_____animated______(const std::function<void(std::optional<bool> /* animated */)>& value) noexcept {
    return std::optional<std::function<void(std::optional<bool> /* animated */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_std__optional_bool_____animated______(const std::optional<std::function<void(std::optional<bool> /* animated */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(std::optional<bool> /* animated */)> get_std__optional_std__function_void_std__optional_bool_____animated______(const std::optional<std::function<void(std::optional<bool> /* animated */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::function<void()>>
  /**
   * Specialized version of `std::optional<std::function<void()>>`.
   */
  using std__optional_std__function_void____ = std::optional<std::function<void()>>;
  inline std::optional<std::function<void()>> create_std__optional_std__function_void____(const std::function<void()>& value) noexcept {
    return std::optional<std::function<void()>>(value);
  }
  inline bool has_value_std__optional_std__function_void____(const std::optional<std::function<void()>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void()> get_std__optional_std__function_void____(const std::optional<std::function<void()>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Distance>
  /**
   * Specialized version of `std::optional<Distance>`.
   */
  using std__optional_Distance_ = std::optional<Distance>;
  inline std::optional<Distance> create_std__optional_Distance_(const Distance& value) noexcept {
    return std::optional<Distance>(value);
  }
  inline bool has_value_std__optional_Distance_(const std::optional<Distance>& optional) noexcept {
    return optional.has_value();
  }
  inline Distance get_std__optional_Distance_(const std::optional<Distance>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroGridButton>
  /**
   * Specialized version of `std::vector<NitroGridButton>`.
   */
  using std__vector_NitroGridButton_ = std::vector<NitroGridButton>;
  inline std::vector<NitroGridButton> create_std__vector_NitroGridButton_(size_t size) noexcept {
    std::vector<NitroGridButton> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<NitroMapButton>
  /**
   * Specialized version of `std::vector<NitroMapButton>`.
   */
  using std__vector_NitroMapButton_ = std::vector<NitroMapButton>;
  inline std::vector<NitroMapButton> create_std__vector_NitroMapButton_(size_t size) noexcept {
    std::vector<NitroMapButton> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroMapButton>>
  /**
   * Specialized version of `std::optional<std::vector<NitroMapButton>>`.
   */
  using std__optional_std__vector_NitroMapButton__ = std::optional<std::vector<NitroMapButton>>;
  inline std::optional<std::vector<NitroMapButton>> create_std__optional_std__vector_NitroMapButton__(const std::vector<NitroMapButton>& value) noexcept {
    return std::optional<std::vector<NitroMapButton>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroMapButton__(const std::optional<std::vector<NitroMapButton>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroMapButton> get_std__optional_std__vector_NitroMapButton__(const std::optional<std::vector<NitroMapButton>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(bool /* isPanningInterfaceVisible */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* isPanningInterfaceVisible */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * isPanningInterfaceVisible * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* isPanningInterfaceVisible */)>&& func): _function(std::make_unique<std::function<void(bool /* isPanningInterfaceVisible */)>>(std::move(func))) {}
    inline void call(bool isPanningInterfaceVisible) const noexcept {
      _function->operator()(isPanningInterfaceVisible);
    }
  private:
    std::unique_ptr<std::function<void(bool /* isPanningInterfaceVisible */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>>
  /**
   * Specialized version of `std::optional<std::function<void(bool / * isPanningInterfaceVisible * /)>>`.
   */
  using std__optional_std__function_void_bool____isPanningInterfaceVisible______ = std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>>;
  inline std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>> create_std__optional_std__function_void_bool____isPanningInterfaceVisible______(const std::function<void(bool /* isPanningInterfaceVisible */)>& value) noexcept {
    return std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_bool____isPanningInterfaceVisible______(const std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(bool /* isPanningInterfaceVisible */)> get_std__optional_std__function_void_bool____isPanningInterfaceVisible______(const std::optional<std::function<void(bool /* isPanningInterfaceVisible */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroBaseMapTemplateConfig>
  /**
   * Specialized version of `std::optional<NitroBaseMapTemplateConfig>`.
   */
  using std__optional_NitroBaseMapTemplateConfig_ = std::optional<NitroBaseMapTemplateConfig>;
  inline std::optional<NitroBaseMapTemplateConfig> create_std__optional_NitroBaseMapTemplateConfig_(const NitroBaseMapTemplateConfig& value) noexcept {
    return std::optional<NitroBaseMapTemplateConfig>(value);
  }
  inline bool has_value_std__optional_NitroBaseMapTemplateConfig_(const std::optional<NitroBaseMapTemplateConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroBaseMapTemplateConfig get_std__optional_NitroBaseMapTemplateConfig_(const std::optional<NitroBaseMapTemplateConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridGridTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridGridTemplateSpec>`.
   */
  using std__shared_ptr_HybridGridTemplateSpec_ = std::shared_ptr<HybridGridTemplateSpec>;
  std::shared_ptr<HybridGridTemplateSpec> create_std__shared_ptr_HybridGridTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridGridTemplateSpec_(std__shared_ptr_HybridGridTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridGridTemplateSpec>
  using std__weak_ptr_HybridGridTemplateSpec_ = std::weak_ptr<HybridGridTemplateSpec>;
  inline std__weak_ptr_HybridGridTemplateSpec_ weakify_std__shared_ptr_HybridGridTemplateSpec_(const std::shared_ptr<HybridGridTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<AutoText>
  /**
   * Specialized version of `std::optional<AutoText>`.
   */
  using std__optional_AutoText_ = std::optional<AutoText>;
  inline std::optional<AutoText> create_std__optional_AutoText_(const AutoText& value) noexcept {
    return std::optional<AutoText>(value);
  }
  inline bool has_value_std__optional_AutoText_(const std::optional<AutoText>& optional) noexcept {
    return optional.has_value();
  }
  inline AutoText get_std__optional_AutoText_(const std::optional<AutoText>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::function<void(std::optional<bool> /* checked */)>>
  /**
   * Specialized version of `std::optional<std::function<void(std::optional<bool> / * checked * /)>>`.
   */
  using std__optional_std__function_void_std__optional_bool_____checked______ = std::optional<std::function<void(std::optional<bool> /* checked */)>>;
  inline std::optional<std::function<void(std::optional<bool> /* checked */)>> create_std__optional_std__function_void_std__optional_bool_____checked______(const std::function<void(std::optional<bool> /* checked */)>& value) noexcept {
    return std::optional<std::function<void(std::optional<bool> /* checked */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_std__optional_bool_____checked______(const std::optional<std::function<void(std::optional<bool> /* checked */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(std::optional<bool> /* checked */)> get_std__optional_std__function_void_std__optional_bool_____checked______(const std::optional<std::function<void(std::optional<bool> /* checked */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroRow>
  /**
   * Specialized version of `std::vector<NitroRow>`.
   */
  using std__vector_NitroRow_ = std::vector<NitroRow>;
  inline std::vector<NitroRow> create_std__vector_NitroRow_(size_t size) noexcept {
    std::vector<NitroRow> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<HybridInformationTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridInformationTemplateSpec>`.
   */
  using std__shared_ptr_HybridInformationTemplateSpec_ = std::shared_ptr<HybridInformationTemplateSpec>;
  std::shared_ptr<HybridInformationTemplateSpec> create_std__shared_ptr_HybridInformationTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridInformationTemplateSpec_(std__shared_ptr_HybridInformationTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridInformationTemplateSpec>
  using std__weak_ptr_HybridInformationTemplateSpec_ = std::weak_ptr<HybridInformationTemplateSpec>;
  inline std__weak_ptr_HybridInformationTemplateSpec_ weakify_std__shared_ptr_HybridInformationTemplateSpec_(const std::shared_ptr<HybridInformationTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::vector<NitroSection>
  /**
   * Specialized version of `std::vector<NitroSection>`.
   */
  using std__vector_NitroSection_ = std::vector<NitroSection>;
  inline std::vector<NitroSection> create_std__vector_NitroSection_(size_t size) noexcept {
    std::vector<NitroSection> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroSection>>
  /**
   * Specialized version of `std::optional<std::vector<NitroSection>>`.
   */
  using std__optional_std__vector_NitroSection__ = std::optional<std::vector<NitroSection>>;
  inline std::optional<std::vector<NitroSection>> create_std__optional_std__vector_NitroSection__(const std::vector<NitroSection>& value) noexcept {
    return std::optional<std::vector<NitroSection>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroSection__(const std::optional<std::vector<NitroSection>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroSection> get_std__optional_std__vector_NitroSection__(const std::optional<std::vector<NitroSection>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridListTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridListTemplateSpec>`.
   */
  using std__shared_ptr_HybridListTemplateSpec_ = std::shared_ptr<HybridListTemplateSpec>;
  std::shared_ptr<HybridListTemplateSpec> create_std__shared_ptr_HybridListTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridListTemplateSpec_(std__shared_ptr_HybridListTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridListTemplateSpec>
  using std__weak_ptr_HybridListTemplateSpec_ = std::weak_ptr<HybridListTemplateSpec>;
  inline std__weak_ptr_HybridListTemplateSpec_ weakify_std__shared_ptr_HybridListTemplateSpec_(const std::shared_ptr<HybridListTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<VisibleTravelEstimate>
  /**
   * Specialized version of `std::optional<VisibleTravelEstimate>`.
   */
  using std__optional_VisibleTravelEstimate_ = std::optional<VisibleTravelEstimate>;
  inline std::optional<VisibleTravelEstimate> create_std__optional_VisibleTravelEstimate_(const VisibleTravelEstimate& value) noexcept {
    return std::optional<VisibleTravelEstimate>(value);
  }
  inline bool has_value_std__optional_VisibleTravelEstimate_(const std::optional<VisibleTravelEstimate>& optional) noexcept {
    return optional.has_value();
  }
  inline VisibleTravelEstimate get_std__optional_VisibleTravelEstimate_(const std::optional<VisibleTravelEstimate>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Point>
  /**
   * Specialized version of `std::optional<Point>`.
   */
  using std__optional_Point_ = std::optional<Point>;
  inline std::optional<Point> create_std__optional_Point_(const Point& value) noexcept {
    return std::optional<Point>(value);
  }
  inline bool has_value_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return optional.has_value();
  }
  inline Point get_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>
  /**
   * Specialized version of `std::function<void(const Point&, const std::optional<Point>&)>`.
   */
  using Func_void_Point_std__optional_Point_ = std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * translation * /, const std::optional<Point>& / * velocity * /)>`, this can be used from Swift.
   */
  class Func_void_Point_std__optional_Point__Wrapper final {
  public:
    explicit Func_void_Point_std__optional_Point__Wrapper(std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>&& func): _function(std::make_unique<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>(std::move(func))) {}
    inline void call(Point translation, std::optional<Point> velocity) const noexcept {
      _function->operator()(translation, velocity);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point_std__optional_Point_ create_Func_void_Point_std__optional_Point_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_std__optional_Point__Wrapper wrap_Func_void_Point_std__optional_Point_(Func_void_Point_std__optional_Point_ value) noexcept {
    return Func_void_Point_std__optional_Point__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * translation * /, const std::optional<Point>& / * velocity * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______ = std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>;
  inline std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>> create_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)> get_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* center */, double /* scale */)>
  /**
   * Specialized version of `std::function<void(const Point&, double)>`.
   */
  using Func_void_Point_double = std::function<void(const Point& /* center */, double /* scale */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * center * /, double / * scale * /)>`, this can be used from Swift.
   */
  class Func_void_Point_double_Wrapper final {
  public:
    explicit Func_void_Point_double_Wrapper(std::function<void(const Point& /* center */, double /* scale */)>&& func): _function(std::make_unique<std::function<void(const Point& /* center */, double /* scale */)>>(std::move(func))) {}
    inline void call(Point center, double scale) const noexcept {
      _function->operator()(center, scale);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* center */, double /* scale */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point_double create_Func_void_Point_double(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_double_Wrapper wrap_Func_void_Point_double(Func_void_Point_double value) noexcept {
    return Func_void_Point_double_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* center */, double /* scale */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * center * /, double / * scale * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____center_____double____scale______ = std::optional<std::function<void(const Point& /* center */, double /* scale */)>>;
  inline std::optional<std::function<void(const Point& /* center */, double /* scale */)>> create_std__optional_std__function_void_const_Point_____center_____double____scale______(const std::function<void(const Point& /* center */, double /* scale */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* center */, double /* scale */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____center_____double____scale______(const std::optional<std::function<void(const Point& /* center */, double /* scale */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* center */, double /* scale */)> get_std__optional_std__function_void_const_Point_____center_____double____scale______(const std::optional<std::function<void(const Point& /* center */, double /* scale */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* center */)>
  /**
   * Specialized version of `std::function<void(const Point&)>`.
   */
  using Func_void_Point = std::function<void(const Point& /* center */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * center * /)>`, this can be used from Swift.
   */
  class Func_void_Point_Wrapper final {
  public:
    explicit Func_void_Point_Wrapper(std::function<void(const Point& /* center */)>&& func): _function(std::make_unique<std::function<void(const Point& /* center */)>>(std::move(func))) {}
    inline void call(Point center) const noexcept {
      _function->operator()(center);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* center */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point create_Func_void_Point(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_Wrapper wrap_Func_void_Point(Func_void_Point value) noexcept {
    return Func_void_Point_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* center */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * center * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____center______ = std::optional<std::function<void(const Point& /* center */)>>;
  inline std::optional<std::function<void(const Point& /* center */)>> create_std__optional_std__function_void_const_Point_____center______(const std::function<void(const Point& /* center */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* center */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____center______(const std::optional<std::function<void(const Point& /* center */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* center */)> get_std__optional_std__function_void_const_Point_____center______(const std::optional<std::function<void(const Point& /* center */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::function<void(ColorScheme /* colorScheme */)>>
  /**
   * Specialized version of `std::optional<std::function<void(ColorScheme / * colorScheme * /)>>`.
   */
  using std__optional_std__function_void_ColorScheme____colorScheme______ = std::optional<std::function<void(ColorScheme /* colorScheme */)>>;
  inline std::optional<std::function<void(ColorScheme /* colorScheme */)>> create_std__optional_std__function_void_ColorScheme____colorScheme______(const std::function<void(ColorScheme /* colorScheme */)>& value) noexcept {
    return std::optional<std::function<void(ColorScheme /* colorScheme */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_ColorScheme____colorScheme______(const std::optional<std::function<void(ColorScheme /* colorScheme */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(ColorScheme /* colorScheme */)> get_std__optional_std__function_void_ColorScheme____colorScheme______(const std::optional<std::function<void(ColorScheme /* colorScheme */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlertActionStyle>
  /**
   * Specialized version of `std::optional<AlertActionStyle>`.
   */
  using std__optional_AlertActionStyle_ = std::optional<AlertActionStyle>;
  inline std::optional<AlertActionStyle> create_std__optional_AlertActionStyle_(const AlertActionStyle& value) noexcept {
    return std::optional<AlertActionStyle>(value);
  }
  inline bool has_value_std__optional_AlertActionStyle_(const std::optional<AlertActionStyle>& optional) noexcept {
    return optional.has_value();
  }
  inline AlertActionStyle get_std__optional_AlertActionStyle_(const std::optional<AlertActionStyle>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NavigationAlertAction>
  /**
   * Specialized version of `std::optional<NavigationAlertAction>`.
   */
  using std__optional_NavigationAlertAction_ = std::optional<NavigationAlertAction>;
  inline std::optional<NavigationAlertAction> create_std__optional_NavigationAlertAction_(const NavigationAlertAction& value) noexcept {
    return std::optional<NavigationAlertAction>(value);
  }
  inline bool has_value_std__optional_NavigationAlertAction_(const std::optional<NavigationAlertAction>& optional) noexcept {
    return optional.has_value();
  }
  inline NavigationAlertAction get_std__optional_NavigationAlertAction_(const std::optional<NavigationAlertAction>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(AlertDismissalReason /* reason */)>
  /**
   * Specialized version of `std::function<void(AlertDismissalReason)>`.
   */
  using Func_void_AlertDismissalReason = std::function<void(AlertDismissalReason /* reason */)>;
  /**
   * Wrapper class for a `std::function<void(AlertDismissalReason / * reason * /)>`, this can be used from Swift.
   */
  class Func_void_AlertDismissalReason_Wrapper final {
  public:
    explicit Func_void_AlertDismissalReason_Wrapper(std::function<void(AlertDismissalReason /* reason */)>&& func): _function(std::make_unique<std::function<void(AlertDismissalReason /* reason */)>>(std::move(func))) {}
    inline void call(int reason) const noexcept {
      _function->operator()(static_cast<AlertDismissalReason>(reason));
    }
  private:
    std::unique_ptr<std::function<void(AlertDismissalReason /* reason */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_AlertDismissalReason create_Func_void_AlertDismissalReason(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_AlertDismissalReason_Wrapper wrap_Func_void_AlertDismissalReason(Func_void_AlertDismissalReason value) noexcept {
    return Func_void_AlertDismissalReason_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(AlertDismissalReason /* reason */)>>
  /**
   * Specialized version of `std::optional<std::function<void(AlertDismissalReason / * reason * /)>>`.
   */
  using std__optional_std__function_void_AlertDismissalReason____reason______ = std::optional<std::function<void(AlertDismissalReason /* reason */)>>;
  inline std::optional<std::function<void(AlertDismissalReason /* reason */)>> create_std__optional_std__function_void_AlertDismissalReason____reason______(const std::function<void(AlertDismissalReason /* reason */)>& value) noexcept {
    return std::optional<std::function<void(AlertDismissalReason /* reason */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_AlertDismissalReason____reason______(const std::optional<std::function<void(AlertDismissalReason /* reason */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(AlertDismissalReason /* reason */)> get_std__optional_std__function_void_AlertDismissalReason____reason______(const std::optional<std::function<void(AlertDismissalReason /* reason */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<TripPoint>
  /**
   * Specialized version of `std::vector<TripPoint>`.
   */
  using std__vector_TripPoint_ = std::vector<TripPoint>;
  inline std::vector<TripPoint> create_std__vector_TripPoint_(size_t size) noexcept {
    std::vector<TripPoint> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<RouteChoice>
  /**
   * Specialized version of `std::vector<RouteChoice>`.
   */
  using std__vector_RouteChoice_ = std::vector<RouteChoice>;
  inline std::vector<RouteChoice> create_std__vector_RouteChoice_(size_t size) noexcept {
    std::vector<RouteChoice> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<TripsConfig>
  /**
   * Specialized version of `std::vector<TripsConfig>`.
   */
  using std__vector_TripsConfig_ = std::vector<TripsConfig>;
  inline std::vector<TripsConfig> create_std__vector_TripsConfig_(size_t size) noexcept {
    std::vector<TripsConfig> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>
  /**
   * Specialized version of `std::function<void(const std::string&, const std::string&)>`.
   */
  using Func_void_std__string_std__string = std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * tripId * /, const std::string& / * routeId * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_std__string_Wrapper(std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>>(std::move(func))) {}
    inline void call(std::string tripId, std::string routeId) const noexcept {
      _function->operator()(tripId, routeId);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_std__string create_Func_void_std__string_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_std__string_Wrapper wrap_Func_void_std__string_std__string(Func_void_std__string_std__string value) noexcept {
    return Func_void_std__string_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<TurnType>
  /**
   * Specialized version of `std::optional<TurnType>`.
   */
  using std__optional_TurnType_ = std::optional<TurnType>;
  inline std::optional<TurnType> create_std__optional_TurnType_(const TurnType& value) noexcept {
    return std::optional<TurnType>(value);
  }
  inline bool has_value_std__optional_TurnType_(const std::optional<TurnType>& optional) noexcept {
    return optional.has_value();
  }
  inline TurnType get_std__optional_TurnType_(const std::optional<TurnType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<double>
  /**
   * Specialized version of `std::vector<double>`.
   */
  using std__vector_double_ = std::vector<double>;
  inline std::vector<double> create_std__vector_double_(size_t size) noexcept {
    std::vector<double> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<double>>
  /**
   * Specialized version of `std::optional<std::vector<double>>`.
   */
  using std__optional_std__vector_double__ = std::optional<std::vector<double>>;
  inline std::optional<std::vector<double>> create_std__optional_std__vector_double__(const std::vector<double>& value) noexcept {
    return std::optional<std::vector<double>>(value);
  }
  inline bool has_value_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<double> get_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<OffRampType>
  /**
   * Specialized version of `std::optional<OffRampType>`.
   */
  using std__optional_OffRampType_ = std::optional<OffRampType>;
  inline std::optional<OffRampType> create_std__optional_OffRampType_(const OffRampType& value) noexcept {
    return std::optional<OffRampType>(value);
  }
  inline bool has_value_std__optional_OffRampType_(const std::optional<OffRampType>& optional) noexcept {
    return optional.has_value();
  }
  inline OffRampType get_std__optional_OffRampType_(const std::optional<OffRampType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<OnRampType>
  /**
   * Specialized version of `std::optional<OnRampType>`.
   */
  using std__optional_OnRampType_ = std::optional<OnRampType>;
  inline std::optional<OnRampType> create_std__optional_OnRampType_(const OnRampType& value) noexcept {
    return std::optional<OnRampType>(value);
  }
  inline bool has_value_std__optional_OnRampType_(const std::optional<OnRampType>& optional) noexcept {
    return optional.has_value();
  }
  inline OnRampType get_std__optional_OnRampType_(const std::optional<OnRampType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ForkType>
  /**
   * Specialized version of `std::optional<ForkType>`.
   */
  using std__optional_ForkType_ = std::optional<ForkType>;
  inline std::optional<ForkType> create_std__optional_ForkType_(const ForkType& value) noexcept {
    return std::optional<ForkType>(value);
  }
  inline bool has_value_std__optional_ForkType_(const std::optional<ForkType>& optional) noexcept {
    return optional.has_value();
  }
  inline ForkType get_std__optional_ForkType_(const std::optional<ForkType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<KeepType>
  /**
   * Specialized version of `std::optional<KeepType>`.
   */
  using std__optional_KeepType_ = std::optional<KeepType>;
  inline std::optional<KeepType> create_std__optional_KeepType_(const KeepType& value) noexcept {
    return std::optional<KeepType>(value);
  }
  inline bool has_value_std__optional_KeepType_(const std::optional<KeepType>& optional) noexcept {
    return optional.has_value();
  }
  inline KeepType get_std__optional_KeepType_(const std::optional<KeepType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<PreferredImageLane, ImageLane>
  /**
   * Wrapper struct for `std::variant<PreferredImageLane, ImageLane>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PreferredImageLane__ImageLane_ {
    std::variant<PreferredImageLane, ImageLane> variant;
    std__variant_PreferredImageLane__ImageLane_(std::variant<PreferredImageLane, ImageLane> variant): variant(variant) { }
    operator std::variant<PreferredImageLane, ImageLane>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PreferredImageLane get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline ImageLane get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_PreferredImageLane__ImageLane_ create_std__variant_PreferredImageLane__ImageLane_(const PreferredImageLane& value) noexcept {
    return std__variant_PreferredImageLane__ImageLane_(value);
  }
  inline std__variant_PreferredImageLane__ImageLane_ create_std__variant_PreferredImageLane__ImageLane_(const ImageLane& value) noexcept {
    return std__variant_PreferredImageLane__ImageLane_(value);
  }
  
  // pragma MARK: std::vector<std::variant<PreferredImageLane, ImageLane>>
  /**
   * Specialized version of `std::vector<std::variant<PreferredImageLane, ImageLane>>`.
   */
  using std__vector_std__variant_PreferredImageLane__ImageLane__ = std::vector<std::variant<PreferredImageLane, ImageLane>>;
  inline std::vector<std::variant<PreferredImageLane, ImageLane>> create_std__vector_std__variant_PreferredImageLane__ImageLane__(size_t size) noexcept {
    std::vector<std::variant<PreferredImageLane, ImageLane>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<LaneGuidance>
  /**
   * Specialized version of `std::optional<LaneGuidance>`.
   */
  using std__optional_LaneGuidance_ = std::optional<LaneGuidance>;
  inline std::optional<LaneGuidance> create_std__optional_LaneGuidance_(const LaneGuidance& value) noexcept {
    return std::optional<LaneGuidance>(value);
  }
  inline bool has_value_std__optional_LaneGuidance_(const std::optional<LaneGuidance>& optional) noexcept {
    return optional.has_value();
  }
  inline LaneGuidance get_std__optional_LaneGuidance_(const std::optional<LaneGuidance>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroRoutingManeuver>
  /**
   * Specialized version of `std::vector<NitroRoutingManeuver>`.
   */
  using std__vector_NitroRoutingManeuver_ = std::vector<NitroRoutingManeuver>;
  inline std::vector<NitroRoutingManeuver> create_std__vector_NitroRoutingManeuver_(size_t size) noexcept {
    std::vector<NitroRoutingManeuver> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<std::vector<NitroRoutingManeuver>, NitroMessageManeuver>
  /**
   * Wrapper struct for `std::variant<std::vector<NitroRoutingManeuver>, NitroMessageManeuver>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_ {
    std::variant<std::vector<NitroRoutingManeuver>, NitroMessageManeuver> variant;
    std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_(std::variant<std::vector<NitroRoutingManeuver>, NitroMessageManeuver> variant): variant(variant) { }
    operator std::variant<std::vector<NitroRoutingManeuver>, NitroMessageManeuver>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline std::vector<NitroRoutingManeuver> get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroMessageManeuver get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_ create_std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_(const std::vector<NitroRoutingManeuver>& value) noexcept {
    return std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_(value);
  }
  inline std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_ create_std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_(const NitroMessageManeuver& value) noexcept {
    return std__variant_std__vector_NitroRoutingManeuver___NitroMessageManeuver_(value);
  }
  
  // pragma MARK: std::shared_ptr<HybridMapTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridMapTemplateSpec>`.
   */
  using std__shared_ptr_HybridMapTemplateSpec_ = std::shared_ptr<HybridMapTemplateSpec>;
  std::shared_ptr<HybridMapTemplateSpec> create_std__shared_ptr_HybridMapTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridMapTemplateSpec_(std__shared_ptr_HybridMapTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridMapTemplateSpec>
  using std__weak_ptr_HybridMapTemplateSpec_ = std::weak_ptr<HybridMapTemplateSpec>;
  inline std__weak_ptr_HybridMapTemplateSpec_ weakify_std__shared_ptr_HybridMapTemplateSpec_(const std::shared_ptr<HybridMapTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<TripSelectorCallback>
  using Result_TripSelectorCallback_ = Result<TripSelectorCallback>;
  inline Result_TripSelectorCallback_ create_Result_TripSelectorCallback_(const TripSelectorCallback& value) noexcept {
    return Result<TripSelectorCallback>::withValue(value);
  }
  inline Result_TripSelectorCallback_ create_Result_TripSelectorCallback_(const std::exception_ptr& error) noexcept {
    return Result<TripSelectorCallback>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridMessageTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridMessageTemplateSpec>`.
   */
  using std__shared_ptr_HybridMessageTemplateSpec_ = std::shared_ptr<HybridMessageTemplateSpec>;
  std::shared_ptr<HybridMessageTemplateSpec> create_std__shared_ptr_HybridMessageTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridMessageTemplateSpec_(std__shared_ptr_HybridMessageTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridMessageTemplateSpec>
  using std__weak_ptr_HybridMessageTemplateSpec_ = std::weak_ptr<HybridMessageTemplateSpec>;
  inline std__weak_ptr_HybridMessageTemplateSpec_ weakify_std__shared_ptr_HybridMessageTemplateSpec_(const std::shared_ptr<HybridMessageTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridSearchTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridSearchTemplateSpec>`.
   */
  using std__shared_ptr_HybridSearchTemplateSpec_ = std::shared_ptr<HybridSearchTemplateSpec>;
  std::shared_ptr<HybridSearchTemplateSpec> create_std__shared_ptr_HybridSearchTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridSearchTemplateSpec_(std__shared_ptr_HybridSearchTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridSearchTemplateSpec>
  using std__weak_ptr_HybridSearchTemplateSpec_ = std::weak_ptr<HybridSearchTemplateSpec>;
  inline std__weak_ptr_HybridSearchTemplateSpec_ weakify_std__shared_ptr_HybridSearchTemplateSpec_(const std::shared_ptr<HybridSearchTemplateSpec>& strong) noexcept { return strong; }

} // namespace margelo::nitro::swe::iternio::reactnativeautoplay::bridge::swift
