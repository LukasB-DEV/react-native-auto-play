///
/// NitroAutoplay-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AlertActionStyle` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class AlertActionStyle; }
// Forward declaration of `AlertDismissalReason` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class AlertDismissalReason; }
// Forward declaration of `AttributedInstructionVariantImage` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct AttributedInstructionVariantImage; }
// Forward declaration of `AttributedInstructionVariant` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct AttributedInstructionVariant; }
// Forward declaration of `AutoText` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct AutoText; }
// Forward declaration of `ColorScheme` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class ColorScheme; }
// Forward declaration of `DistanceUnits` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class DistanceUnits; }
// Forward declaration of `Distance` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct Distance; }
// Forward declaration of `DurationWithTimeZone` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct DurationWithTimeZone; }
// Forward declaration of `ForkType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class ForkType; }
// Forward declaration of `HybridHybridAutoPlaySpec` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { class HybridHybridAutoPlaySpec; }
// Forward declaration of `HybridHybridGridTemplateSpec` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { class HybridHybridGridTemplateSpec; }
// Forward declaration of `HybridHybridListTemplateSpec` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { class HybridHybridListTemplateSpec; }
// Forward declaration of `HybridHybridMapTemplateSpec` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { class HybridHybridMapTemplateSpec; }
// Forward declaration of `HybridHybridMessageTemplateSpec` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { class HybridHybridMessageTemplateSpec; }
// Forward declaration of `KeepType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class KeepType; }
// Forward declaration of `LaneGuidance` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct LaneGuidance; }
// Forward declaration of `LaneStatus` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class LaneStatus; }
// Forward declaration of `Lane` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct Lane; }
// Forward declaration of `ManeuverType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class ManeuverType; }
// Forward declaration of `NavigationAlertAction` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NavigationAlertAction; }
// Forward declaration of `NitroActionType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class NitroActionType; }
// Forward declaration of `NitroAction` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroAction; }
// Forward declaration of `NitroAlignment` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class NitroAlignment; }
// Forward declaration of `NitroColor` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroColor; }
// Forward declaration of `NitroGridButton` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroGridButton; }
// Forward declaration of `NitroImage` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroImage; }
// Forward declaration of `NitroManeuver` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroManeuver; }
// Forward declaration of `NitroMapButtonType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class NitroMapButtonType; }
// Forward declaration of `NitroMapButton` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroMapButton; }
// Forward declaration of `NitroRow` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroRow; }
// Forward declaration of `NitroSectionType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class NitroSectionType; }
// Forward declaration of `NitroSection` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct NitroSection; }
// Forward declaration of `OffRampType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class OffRampType; }
// Forward declaration of `OnRampType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class OnRampType; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct Point; }
// Forward declaration of `RouteChoice` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct RouteChoice; }
// Forward declaration of `SafeAreaInsets` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct SafeAreaInsets; }
// Forward declaration of `TrafficSide` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class TrafficSide; }
// Forward declaration of `TravelEstimates` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct TravelEstimates; }
// Forward declaration of `TripPoint` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct TripPoint; }
// Forward declaration of `TripsConfig` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { struct TripsConfig; }
// Forward declaration of `TurnType` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class TurnType; }
// Forward declaration of `VisibilityState` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class VisibilityState; }
// Forward declaration of `VisibleTravelEstimate` to properly resolve imports.
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid { enum class VisibleTravelEstimate; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridHybridAutoPlaySpec_cxx` to properly resolve imports.
namespace NitroAutoplay { class HybridHybridAutoPlaySpec_cxx; }
// Forward declaration of `HybridHybridGridTemplateSpec_cxx` to properly resolve imports.
namespace NitroAutoplay { class HybridHybridGridTemplateSpec_cxx; }
// Forward declaration of `HybridHybridListTemplateSpec_cxx` to properly resolve imports.
namespace NitroAutoplay { class HybridHybridListTemplateSpec_cxx; }
// Forward declaration of `HybridHybridMapTemplateSpec_cxx` to properly resolve imports.
namespace NitroAutoplay { class HybridHybridMapTemplateSpec_cxx; }
// Forward declaration of `HybridHybridMessageTemplateSpec_cxx` to properly resolve imports.
namespace NitroAutoplay { class HybridHybridMessageTemplateSpec_cxx; }

// Include C++ defined types
#include "AlertActionStyle.hpp"
#include "AlertDismissalReason.hpp"
#include "AttributedInstructionVariant.hpp"
#include "AttributedInstructionVariantImage.hpp"
#include "AutoText.hpp"
#include "ColorScheme.hpp"
#include "Distance.hpp"
#include "DistanceUnits.hpp"
#include "DurationWithTimeZone.hpp"
#include "ForkType.hpp"
#include "HybridHybridAutoPlaySpec.hpp"
#include "HybridHybridGridTemplateSpec.hpp"
#include "HybridHybridListTemplateSpec.hpp"
#include "HybridHybridMapTemplateSpec.hpp"
#include "HybridHybridMessageTemplateSpec.hpp"
#include "KeepType.hpp"
#include "Lane.hpp"
#include "LaneGuidance.hpp"
#include "LaneStatus.hpp"
#include "ManeuverType.hpp"
#include "NavigationAlertAction.hpp"
#include "NitroAction.hpp"
#include "NitroActionType.hpp"
#include "NitroAlignment.hpp"
#include "NitroColor.hpp"
#include "NitroGridButton.hpp"
#include "NitroImage.hpp"
#include "NitroManeuver.hpp"
#include "NitroMapButton.hpp"
#include "NitroMapButtonType.hpp"
#include "NitroRow.hpp"
#include "NitroSection.hpp"
#include "NitroSectionType.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "Point.hpp"
#include "RouteChoice.hpp"
#include "SafeAreaInsets.hpp"
#include "TrafficSide.hpp"
#include "TravelEstimates.hpp"
#include "TripPoint.hpp"
#include "TripsConfig.hpp"
#include "TurnType.hpp"
#include "VisibilityState.hpp"
#include "VisibleTravelEstimate.hpp"
#include <NitroModules/FastVectorCopy.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid::bridge::swift {

  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(VisibilityState /* payload */)>
  /**
   * Specialized version of `std::function<void(VisibilityState)>`.
   */
  using Func_void_VisibilityState = std::function<void(VisibilityState /* payload */)>;
  /**
   * Wrapper class for a `std::function<void(VisibilityState / * payload * /)>`, this can be used from Swift.
   */
  class Func_void_VisibilityState_Wrapper final {
  public:
    explicit Func_void_VisibilityState_Wrapper(std::function<void(VisibilityState /* payload */)>&& func): _function(std::make_unique<std::function<void(VisibilityState /* payload */)>>(std::move(func))) {}
    inline void call(int payload) const noexcept {
      _function->operator()(static_cast<VisibilityState>(payload));
    }
  private:
    std::unique_ptr<std::function<void(VisibilityState /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_VisibilityState create_Func_void_VisibilityState(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_VisibilityState_Wrapper wrap_Func_void_VisibilityState(Func_void_VisibilityState value) noexcept {
    return Func_void_VisibilityState_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() noexcept {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) noexcept {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const SafeAreaInsets& /* insets */)>
  /**
   * Specialized version of `std::function<void(const SafeAreaInsets&)>`.
   */
  using Func_void_SafeAreaInsets = std::function<void(const SafeAreaInsets& /* insets */)>;
  /**
   * Wrapper class for a `std::function<void(const SafeAreaInsets& / * insets * /)>`, this can be used from Swift.
   */
  class Func_void_SafeAreaInsets_Wrapper final {
  public:
    explicit Func_void_SafeAreaInsets_Wrapper(std::function<void(const SafeAreaInsets& /* insets */)>&& func): _function(std::make_unique<std::function<void(const SafeAreaInsets& /* insets */)>>(std::move(func))) {}
    inline void call(SafeAreaInsets insets) const noexcept {
      _function->operator()(insets);
    }
  private:
    std::unique_ptr<std::function<void(const SafeAreaInsets& /* insets */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_SafeAreaInsets create_Func_void_SafeAreaInsets(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_SafeAreaInsets_Wrapper wrap_Func_void_SafeAreaInsets(Func_void_SafeAreaInsets value) noexcept {
    return Func_void_SafeAreaInsets_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroImage>
  /**
   * Specialized version of `std::optional<NitroImage>`.
   */
  using std__optional_NitroImage_ = std::optional<NitroImage>;
  inline std::optional<NitroImage> create_std__optional_NitroImage_(const NitroImage& value) noexcept {
    return std::optional<NitroImage>(value);
  }
  inline bool has_value_std__optional_NitroImage_(const std::optional<NitroImage>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroImage get_std__optional_NitroImage_(const std::optional<NitroImage>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAlignment>
  /**
   * Specialized version of `std::optional<NitroAlignment>`.
   */
  using std__optional_NitroAlignment_ = std::optional<NitroAlignment>;
  inline std::optional<NitroAlignment> create_std__optional_NitroAlignment_(const NitroAlignment& value) noexcept {
    return std::optional<NitroAlignment>(value);
  }
  inline bool has_value_std__optional_NitroAlignment_(const std::optional<NitroAlignment>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAlignment get_std__optional_NitroAlignment_(const std::optional<NitroAlignment>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlertActionStyle>
  /**
   * Specialized version of `std::optional<AlertActionStyle>`.
   */
  using std__optional_AlertActionStyle_ = std::optional<AlertActionStyle>;
  inline std::optional<AlertActionStyle> create_std__optional_AlertActionStyle_(const AlertActionStyle& value) noexcept {
    return std::optional<AlertActionStyle>(value);
  }
  inline bool has_value_std__optional_AlertActionStyle_(const std::optional<AlertActionStyle>& optional) noexcept {
    return optional.has_value();
  }
  inline AlertActionStyle get_std__optional_AlertActionStyle_(const std::optional<AlertActionStyle>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroAction>
  /**
   * Specialized version of `std::vector<NitroAction>`.
   */
  using std__vector_NitroAction_ = std::vector<NitroAction>;
  inline std::vector<NitroAction> create_std__vector_NitroAction_(size_t size) noexcept {
    std::vector<NitroAction> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroAction>>
  /**
   * Specialized version of `std::optional<std::vector<NitroAction>>`.
   */
  using std__optional_std__vector_NitroAction__ = std::optional<std::vector<NitroAction>>;
  inline std::optional<std::vector<NitroAction>> create_std__optional_std__vector_NitroAction__(const std::vector<NitroAction>& value) noexcept {
    return std::optional<std::vector<NitroAction>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroAction__(const std::optional<std::vector<NitroAction>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroAction> get_std__optional_std__vector_NitroAction__(const std::optional<std::vector<NitroAction>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridHybridAutoPlaySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHybridAutoPlaySpec>`.
   */
  using std__shared_ptr_HybridHybridAutoPlaySpec_ = std::shared_ptr<HybridHybridAutoPlaySpec>;
  std::shared_ptr<HybridHybridAutoPlaySpec> create_std__shared_ptr_HybridHybridAutoPlaySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHybridAutoPlaySpec_(std__shared_ptr_HybridHybridAutoPlaySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHybridAutoPlaySpec>
  using std__weak_ptr_HybridHybridAutoPlaySpec_ = std::weak_ptr<HybridHybridAutoPlaySpec>;
  inline std__weak_ptr_HybridHybridAutoPlaySpec_ weakify_std__shared_ptr_HybridHybridAutoPlaySpec_(const std::shared_ptr<HybridHybridAutoPlaySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::function<void()>>
  using Result_std__function_void____ = Result<std::function<void()>>;
  inline Result_std__function_void____ create_Result_std__function_void____(const std::function<void()>& value) noexcept {
    return Result<std::function<void()>>::withValue(value);
  }
  inline Result_std__function_void____ create_Result_std__function_void____(const std::exception_ptr& error) noexcept {
    return Result<std::function<void()>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: std::function<void(std::optional<bool> /* animated */)>
  /**
   * Specialized version of `std::function<void(std::optional<bool>)>`.
   */
  using Func_void_std__optional_bool_ = std::function<void(std::optional<bool> /* animated */)>;
  /**
   * Wrapper class for a `std::function<void(std::optional<bool> / * animated * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_bool__Wrapper final {
  public:
    explicit Func_void_std__optional_bool__Wrapper(std::function<void(std::optional<bool> /* animated */)>&& func): _function(std::make_unique<std::function<void(std::optional<bool> /* animated */)>>(std::move(func))) {}
    inline void call(std::optional<bool> animated) const noexcept {
      _function->operator()(animated);
    }
  private:
    std::unique_ptr<std::function<void(std::optional<bool> /* animated */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_bool_ create_Func_void_std__optional_bool_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_bool__Wrapper wrap_Func_void_std__optional_bool_(Func_void_std__optional_bool_ value) noexcept {
    return Func_void_std__optional_bool__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(std::optional<bool> /* animated */)>>
  /**
   * Specialized version of `std::optional<std::function<void(std::optional<bool> / * animated * /)>>`.
   */
  using std__optional_std__function_void_std__optional_bool_____animated______ = std::optional<std::function<void(std::optional<bool> /* animated */)>>;
  inline std::optional<std::function<void(std::optional<bool> /* animated */)>> create_std__optional_std__function_void_std__optional_bool_____animated______(const std::function<void(std::optional<bool> /* animated */)>& value) noexcept {
    return std::optional<std::function<void(std::optional<bool> /* animated */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_std__optional_bool_____animated______(const std::optional<std::function<void(std::optional<bool> /* animated */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(std::optional<bool> /* animated */)> get_std__optional_std__function_void_std__optional_bool_____animated______(const std::optional<std::function<void(std::optional<bool> /* animated */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::function<void()>>
  /**
   * Specialized version of `std::optional<std::function<void()>>`.
   */
  using std__optional_std__function_void____ = std::optional<std::function<void()>>;
  inline std::optional<std::function<void()>> create_std__optional_std__function_void____(const std::function<void()>& value) noexcept {
    return std::optional<std::function<void()>>(value);
  }
  inline bool has_value_std__optional_std__function_void____(const std::optional<std::function<void()>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void()> get_std__optional_std__function_void____(const std::optional<std::function<void()>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Distance>
  /**
   * Specialized version of `std::optional<Distance>`.
   */
  using std__optional_Distance_ = std::optional<Distance>;
  inline std::optional<Distance> create_std__optional_Distance_(const Distance& value) noexcept {
    return std::optional<Distance>(value);
  }
  inline bool has_value_std__optional_Distance_(const std::optional<Distance>& optional) noexcept {
    return optional.has_value();
  }
  inline Distance get_std__optional_Distance_(const std::optional<Distance>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroGridButton>
  /**
   * Specialized version of `std::vector<NitroGridButton>`.
   */
  using std__vector_NitroGridButton_ = std::vector<NitroGridButton>;
  inline std::vector<NitroGridButton> create_std__vector_NitroGridButton_(size_t size) noexcept {
    std::vector<NitroGridButton> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<HybridHybridGridTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHybridGridTemplateSpec>`.
   */
  using std__shared_ptr_HybridHybridGridTemplateSpec_ = std::shared_ptr<HybridHybridGridTemplateSpec>;
  std::shared_ptr<HybridHybridGridTemplateSpec> create_std__shared_ptr_HybridHybridGridTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHybridGridTemplateSpec_(std__shared_ptr_HybridHybridGridTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHybridGridTemplateSpec>
  using std__weak_ptr_HybridHybridGridTemplateSpec_ = std::weak_ptr<HybridHybridGridTemplateSpec>;
  inline std__weak_ptr_HybridHybridGridTemplateSpec_ weakify_std__shared_ptr_HybridHybridGridTemplateSpec_(const std::shared_ptr<HybridHybridGridTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<AutoText>
  /**
   * Specialized version of `std::optional<AutoText>`.
   */
  using std__optional_AutoText_ = std::optional<AutoText>;
  inline std::optional<AutoText> create_std__optional_AutoText_(const AutoText& value) noexcept {
    return std::optional<AutoText>(value);
  }
  inline bool has_value_std__optional_AutoText_(const std::optional<AutoText>& optional) noexcept {
    return optional.has_value();
  }
  inline AutoText get_std__optional_AutoText_(const std::optional<AutoText>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroRow>
  /**
   * Specialized version of `std::vector<NitroRow>`.
   */
  using std__vector_NitroRow_ = std::vector<NitroRow>;
  inline std::vector<NitroRow> create_std__vector_NitroRow_(size_t size) noexcept {
    std::vector<NitroRow> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<NitroSection>
  /**
   * Specialized version of `std::vector<NitroSection>`.
   */
  using std__vector_NitroSection_ = std::vector<NitroSection>;
  inline std::vector<NitroSection> create_std__vector_NitroSection_(size_t size) noexcept {
    std::vector<NitroSection> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroSection>>
  /**
   * Specialized version of `std::optional<std::vector<NitroSection>>`.
   */
  using std__optional_std__vector_NitroSection__ = std::optional<std::vector<NitroSection>>;
  inline std::optional<std::vector<NitroSection>> create_std__optional_std__vector_NitroSection__(const std::vector<NitroSection>& value) noexcept {
    return std::optional<std::vector<NitroSection>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroSection__(const std::optional<std::vector<NitroSection>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroSection> get_std__optional_std__vector_NitroSection__(const std::optional<std::vector<NitroSection>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridHybridListTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHybridListTemplateSpec>`.
   */
  using std__shared_ptr_HybridHybridListTemplateSpec_ = std::shared_ptr<HybridHybridListTemplateSpec>;
  std::shared_ptr<HybridHybridListTemplateSpec> create_std__shared_ptr_HybridHybridListTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHybridListTemplateSpec_(std__shared_ptr_HybridHybridListTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHybridListTemplateSpec>
  using std__weak_ptr_HybridHybridListTemplateSpec_ = std::weak_ptr<HybridHybridListTemplateSpec>;
  inline std__weak_ptr_HybridHybridListTemplateSpec_ weakify_std__shared_ptr_HybridHybridListTemplateSpec_(const std::shared_ptr<HybridHybridListTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::vector<NitroMapButton>
  /**
   * Specialized version of `std::vector<NitroMapButton>`.
   */
  using std__vector_NitroMapButton_ = std::vector<NitroMapButton>;
  inline std::vector<NitroMapButton> create_std__vector_NitroMapButton_(size_t size) noexcept {
    std::vector<NitroMapButton> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroMapButton>>
  /**
   * Specialized version of `std::optional<std::vector<NitroMapButton>>`.
   */
  using std__optional_std__vector_NitroMapButton__ = std::optional<std::vector<NitroMapButton>>;
  inline std::optional<std::vector<NitroMapButton>> create_std__optional_std__vector_NitroMapButton__(const std::vector<NitroMapButton>& value) noexcept {
    return std::optional<std::vector<NitroMapButton>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroMapButton__(const std::optional<std::vector<NitroMapButton>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroMapButton> get_std__optional_std__vector_NitroMapButton__(const std::optional<std::vector<NitroMapButton>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroColor>
  /**
   * Specialized version of `std::optional<NitroColor>`.
   */
  using std__optional_NitroColor_ = std::optional<NitroColor>;
  inline std::optional<NitroColor> create_std__optional_NitroColor_(const NitroColor& value) noexcept {
    return std::optional<NitroColor>(value);
  }
  inline bool has_value_std__optional_NitroColor_(const std::optional<NitroColor>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroColor get_std__optional_NitroColor_(const std::optional<NitroColor>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<VisibleTravelEstimate>
  /**
   * Specialized version of `std::optional<VisibleTravelEstimate>`.
   */
  using std__optional_VisibleTravelEstimate_ = std::optional<VisibleTravelEstimate>;
  inline std::optional<VisibleTravelEstimate> create_std__optional_VisibleTravelEstimate_(const VisibleTravelEstimate& value) noexcept {
    return std::optional<VisibleTravelEstimate>(value);
  }
  inline bool has_value_std__optional_VisibleTravelEstimate_(const std::optional<VisibleTravelEstimate>& optional) noexcept {
    return optional.has_value();
  }
  inline VisibleTravelEstimate get_std__optional_VisibleTravelEstimate_(const std::optional<VisibleTravelEstimate>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Point>
  /**
   * Specialized version of `std::optional<Point>`.
   */
  using std__optional_Point_ = std::optional<Point>;
  inline std::optional<Point> create_std__optional_Point_(const Point& value) noexcept {
    return std::optional<Point>(value);
  }
  inline bool has_value_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return optional.has_value();
  }
  inline Point get_std__optional_Point_(const std::optional<Point>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>
  /**
   * Specialized version of `std::function<void(const Point&, const std::optional<Point>&)>`.
   */
  using Func_void_Point_std__optional_Point_ = std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * translation * /, const std::optional<Point>& / * velocity * /)>`, this can be used from Swift.
   */
  class Func_void_Point_std__optional_Point__Wrapper final {
  public:
    explicit Func_void_Point_std__optional_Point__Wrapper(std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>&& func): _function(std::make_unique<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>(std::move(func))) {}
    inline void call(Point translation, std::optional<Point> velocity) const noexcept {
      _function->operator()(translation, velocity);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point_std__optional_Point_ create_Func_void_Point_std__optional_Point_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_std__optional_Point__Wrapper wrap_Func_void_Point_std__optional_Point_(Func_void_Point_std__optional_Point_ value) noexcept {
    return Func_void_Point_std__optional_Point__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * translation * /, const std::optional<Point>& / * velocity * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______ = std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>;
  inline std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>> create_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)> get_std__optional_std__function_void_const_Point_____translation_____const_std__optional_Point______velocity______(const std::optional<std::function<void(const Point& /* translation */, const std::optional<Point>& /* velocity */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>
  /**
   * Specialized version of `std::function<void(const Point&, double, std::optional<double>)>`.
   */
  using Func_void_Point_double_std__optional_double_ = std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * center * /, double / * scale * /, std::optional<double> / * velocity * /)>`, this can be used from Swift.
   */
  class Func_void_Point_double_std__optional_double__Wrapper final {
  public:
    explicit Func_void_Point_double_std__optional_double__Wrapper(std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>&& func): _function(std::make_unique<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>(std::move(func))) {}
    inline void call(Point center, double scale, std::optional<double> velocity) const noexcept {
      _function->operator()(center, scale, velocity);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point_double_std__optional_double_ create_Func_void_Point_double_std__optional_double_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_double_std__optional_double__Wrapper wrap_Func_void_Point_double_std__optional_double_(Func_void_Point_double_std__optional_double_ value) noexcept {
    return Func_void_Point_double_std__optional_double__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * center * /, double / * scale * /, std::optional<double> / * velocity * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____center_____double____scale_____std__optional_double_____velocity______ = std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>;
  inline std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>> create_std__optional_std__function_void_const_Point_____center_____double____scale_____std__optional_double_____velocity______(const std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____center_____double____scale_____std__optional_double_____velocity______(const std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)> get_std__optional_std__function_void_const_Point_____center_____double____scale_____std__optional_double_____velocity______(const std::optional<std::function<void(const Point& /* center */, double /* scale */, std::optional<double> /* velocity */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const Point& /* center */)>
  /**
   * Specialized version of `std::function<void(const Point&)>`.
   */
  using Func_void_Point = std::function<void(const Point& /* center */)>;
  /**
   * Wrapper class for a `std::function<void(const Point& / * center * /)>`, this can be used from Swift.
   */
  class Func_void_Point_Wrapper final {
  public:
    explicit Func_void_Point_Wrapper(std::function<void(const Point& /* center */)>&& func): _function(std::make_unique<std::function<void(const Point& /* center */)>>(std::move(func))) {}
    inline void call(Point center) const noexcept {
      _function->operator()(center);
    }
  private:
    std::unique_ptr<std::function<void(const Point& /* center */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_Point create_Func_void_Point(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Point_Wrapper wrap_Func_void_Point(Func_void_Point value) noexcept {
    return Func_void_Point_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(const Point& /* center */)>>
  /**
   * Specialized version of `std::optional<std::function<void(const Point& / * center * /)>>`.
   */
  using std__optional_std__function_void_const_Point_____center______ = std::optional<std::function<void(const Point& /* center */)>>;
  inline std::optional<std::function<void(const Point& /* center */)>> create_std__optional_std__function_void_const_Point_____center______(const std::function<void(const Point& /* center */)>& value) noexcept {
    return std::optional<std::function<void(const Point& /* center */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_const_Point_____center______(const std::optional<std::function<void(const Point& /* center */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(const Point& /* center */)> get_std__optional_std__function_void_const_Point_____center______(const std::optional<std::function<void(const Point& /* center */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(ColorScheme /* colorScheme */)>
  /**
   * Specialized version of `std::function<void(ColorScheme)>`.
   */
  using Func_void_ColorScheme = std::function<void(ColorScheme /* colorScheme */)>;
  /**
   * Wrapper class for a `std::function<void(ColorScheme / * colorScheme * /)>`, this can be used from Swift.
   */
  class Func_void_ColorScheme_Wrapper final {
  public:
    explicit Func_void_ColorScheme_Wrapper(std::function<void(ColorScheme /* colorScheme */)>&& func): _function(std::make_unique<std::function<void(ColorScheme /* colorScheme */)>>(std::move(func))) {}
    inline void call(int colorScheme) const noexcept {
      _function->operator()(static_cast<ColorScheme>(colorScheme));
    }
  private:
    std::unique_ptr<std::function<void(ColorScheme /* colorScheme */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_ColorScheme create_Func_void_ColorScheme(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_ColorScheme_Wrapper wrap_Func_void_ColorScheme(Func_void_ColorScheme value) noexcept {
    return Func_void_ColorScheme_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(ColorScheme /* colorScheme */)>>
  /**
   * Specialized version of `std::optional<std::function<void(ColorScheme / * colorScheme * /)>>`.
   */
  using std__optional_std__function_void_ColorScheme____colorScheme______ = std::optional<std::function<void(ColorScheme /* colorScheme */)>>;
  inline std::optional<std::function<void(ColorScheme /* colorScheme */)>> create_std__optional_std__function_void_ColorScheme____colorScheme______(const std::function<void(ColorScheme /* colorScheme */)>& value) noexcept {
    return std::optional<std::function<void(ColorScheme /* colorScheme */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_ColorScheme____colorScheme______(const std::optional<std::function<void(ColorScheme /* colorScheme */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(ColorScheme /* colorScheme */)> get_std__optional_std__function_void_ColorScheme____colorScheme______(const std::optional<std::function<void(ColorScheme /* colorScheme */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NavigationAlertAction>
  /**
   * Specialized version of `std::optional<NavigationAlertAction>`.
   */
  using std__optional_NavigationAlertAction_ = std::optional<NavigationAlertAction>;
  inline std::optional<NavigationAlertAction> create_std__optional_NavigationAlertAction_(const NavigationAlertAction& value) noexcept {
    return std::optional<NavigationAlertAction>(value);
  }
  inline bool has_value_std__optional_NavigationAlertAction_(const std::optional<NavigationAlertAction>& optional) noexcept {
    return optional.has_value();
  }
  inline NavigationAlertAction get_std__optional_NavigationAlertAction_(const std::optional<NavigationAlertAction>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(AlertDismissalReason /* reason */)>
  /**
   * Specialized version of `std::function<void(AlertDismissalReason)>`.
   */
  using Func_void_AlertDismissalReason = std::function<void(AlertDismissalReason /* reason */)>;
  /**
   * Wrapper class for a `std::function<void(AlertDismissalReason / * reason * /)>`, this can be used from Swift.
   */
  class Func_void_AlertDismissalReason_Wrapper final {
  public:
    explicit Func_void_AlertDismissalReason_Wrapper(std::function<void(AlertDismissalReason /* reason */)>&& func): _function(std::make_unique<std::function<void(AlertDismissalReason /* reason */)>>(std::move(func))) {}
    inline void call(int reason) const noexcept {
      _function->operator()(static_cast<AlertDismissalReason>(reason));
    }
  private:
    std::unique_ptr<std::function<void(AlertDismissalReason /* reason */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_AlertDismissalReason create_Func_void_AlertDismissalReason(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_AlertDismissalReason_Wrapper wrap_Func_void_AlertDismissalReason(Func_void_AlertDismissalReason value) noexcept {
    return Func_void_AlertDismissalReason_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<void(AlertDismissalReason /* reason */)>>
  /**
   * Specialized version of `std::optional<std::function<void(AlertDismissalReason / * reason * /)>>`.
   */
  using std__optional_std__function_void_AlertDismissalReason____reason______ = std::optional<std::function<void(AlertDismissalReason /* reason */)>>;
  inline std::optional<std::function<void(AlertDismissalReason /* reason */)>> create_std__optional_std__function_void_AlertDismissalReason____reason______(const std::function<void(AlertDismissalReason /* reason */)>& value) noexcept {
    return std::optional<std::function<void(AlertDismissalReason /* reason */)>>(value);
  }
  inline bool has_value_std__optional_std__function_void_AlertDismissalReason____reason______(const std::optional<std::function<void(AlertDismissalReason /* reason */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<void(AlertDismissalReason /* reason */)> get_std__optional_std__function_void_AlertDismissalReason____reason______(const std::optional<std::function<void(AlertDismissalReason /* reason */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<TripPoint>
  /**
   * Specialized version of `std::vector<TripPoint>`.
   */
  using std__vector_TripPoint_ = std::vector<TripPoint>;
  inline std::vector<TripPoint> create_std__vector_TripPoint_(size_t size) noexcept {
    std::vector<TripPoint> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<RouteChoice>
  /**
   * Specialized version of `std::vector<RouteChoice>`.
   */
  using std__vector_RouteChoice_ = std::vector<RouteChoice>;
  inline std::vector<RouteChoice> create_std__vector_RouteChoice_(size_t size) noexcept {
    std::vector<RouteChoice> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<TripsConfig>
  /**
   * Specialized version of `std::vector<TripsConfig>`.
   */
  using std__vector_TripsConfig_ = std::vector<TripsConfig>;
  inline std::vector<TripsConfig> create_std__vector_TripsConfig_(size_t size) noexcept {
    std::vector<TripsConfig> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>
  /**
   * Specialized version of `std::function<void(const std::string&, const std::string&)>`.
   */
  using Func_void_std__string_std__string = std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * tripId * /, const std::string& / * routeId * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_std__string_Wrapper(std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>>(std::move(func))) {}
    inline void call(std::string tripId, std::string routeId) const noexcept {
      _function->operator()(tripId, routeId);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* tripId */, const std::string& /* routeId */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_std__string create_Func_void_std__string_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_std__string_Wrapper wrap_Func_void_std__string_std__string(Func_void_std__string_std__string value) noexcept {
    return Func_void_std__string_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<AttributedInstructionVariantImage>
  /**
   * Specialized version of `std::vector<AttributedInstructionVariantImage>`.
   */
  using std__vector_AttributedInstructionVariantImage_ = std::vector<AttributedInstructionVariantImage>;
  inline std::vector<AttributedInstructionVariantImage> create_std__vector_AttributedInstructionVariantImage_(size_t size) noexcept {
    std::vector<AttributedInstructionVariantImage> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<AttributedInstructionVariantImage>>
  /**
   * Specialized version of `std::optional<std::vector<AttributedInstructionVariantImage>>`.
   */
  using std__optional_std__vector_AttributedInstructionVariantImage__ = std::optional<std::vector<AttributedInstructionVariantImage>>;
  inline std::optional<std::vector<AttributedInstructionVariantImage>> create_std__optional_std__vector_AttributedInstructionVariantImage__(const std::vector<AttributedInstructionVariantImage>& value) noexcept {
    return std::optional<std::vector<AttributedInstructionVariantImage>>(value);
  }
  inline bool has_value_std__optional_std__vector_AttributedInstructionVariantImage__(const std::optional<std::vector<AttributedInstructionVariantImage>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<AttributedInstructionVariantImage> get_std__optional_std__vector_AttributedInstructionVariantImage__(const std::optional<std::vector<AttributedInstructionVariantImage>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<AttributedInstructionVariant>
  /**
   * Specialized version of `std::vector<AttributedInstructionVariant>`.
   */
  using std__vector_AttributedInstructionVariant_ = std::vector<AttributedInstructionVariant>;
  inline std::vector<AttributedInstructionVariant> create_std__vector_AttributedInstructionVariant_(size_t size) noexcept {
    std::vector<AttributedInstructionVariant> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<TurnType>
  /**
   * Specialized version of `std::optional<TurnType>`.
   */
  using std__optional_TurnType_ = std::optional<TurnType>;
  inline std::optional<TurnType> create_std__optional_TurnType_(const TurnType& value) noexcept {
    return std::optional<TurnType>(value);
  }
  inline bool has_value_std__optional_TurnType_(const std::optional<TurnType>& optional) noexcept {
    return optional.has_value();
  }
  inline TurnType get_std__optional_TurnType_(const std::optional<TurnType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<double>
  /**
   * Specialized version of `std::vector<double>`.
   */
  using std__vector_double_ = std::vector<double>;
  inline std::vector<double> copy_std__vector_double_(const double* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<double>(data, size);
  }
  inline const double* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_double_(const std::vector<double>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::optional<std::vector<double>>
  /**
   * Specialized version of `std::optional<std::vector<double>>`.
   */
  using std__optional_std__vector_double__ = std::optional<std::vector<double>>;
  inline std::optional<std::vector<double>> create_std__optional_std__vector_double__(const std::vector<double>& value) noexcept {
    return std::optional<std::vector<double>>(value);
  }
  inline bool has_value_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<double> get_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<OffRampType>
  /**
   * Specialized version of `std::optional<OffRampType>`.
   */
  using std__optional_OffRampType_ = std::optional<OffRampType>;
  inline std::optional<OffRampType> create_std__optional_OffRampType_(const OffRampType& value) noexcept {
    return std::optional<OffRampType>(value);
  }
  inline bool has_value_std__optional_OffRampType_(const std::optional<OffRampType>& optional) noexcept {
    return optional.has_value();
  }
  inline OffRampType get_std__optional_OffRampType_(const std::optional<OffRampType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<OnRampType>
  /**
   * Specialized version of `std::optional<OnRampType>`.
   */
  using std__optional_OnRampType_ = std::optional<OnRampType>;
  inline std::optional<OnRampType> create_std__optional_OnRampType_(const OnRampType& value) noexcept {
    return std::optional<OnRampType>(value);
  }
  inline bool has_value_std__optional_OnRampType_(const std::optional<OnRampType>& optional) noexcept {
    return optional.has_value();
  }
  inline OnRampType get_std__optional_OnRampType_(const std::optional<OnRampType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ForkType>
  /**
   * Specialized version of `std::optional<ForkType>`.
   */
  using std__optional_ForkType_ = std::optional<ForkType>;
  inline std::optional<ForkType> create_std__optional_ForkType_(const ForkType& value) noexcept {
    return std::optional<ForkType>(value);
  }
  inline bool has_value_std__optional_ForkType_(const std::optional<ForkType>& optional) noexcept {
    return optional.has_value();
  }
  inline ForkType get_std__optional_ForkType_(const std::optional<ForkType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<KeepType>
  /**
   * Specialized version of `std::optional<KeepType>`.
   */
  using std__optional_KeepType_ = std::optional<KeepType>;
  inline std::optional<KeepType> create_std__optional_KeepType_(const KeepType& value) noexcept {
    return std::optional<KeepType>(value);
  }
  inline bool has_value_std__optional_KeepType_(const std::optional<KeepType>& optional) noexcept {
    return optional.has_value();
  }
  inline KeepType get_std__optional_KeepType_(const std::optional<KeepType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<Lane>
  /**
   * Specialized version of `std::vector<Lane>`.
   */
  using std__vector_Lane_ = std::vector<Lane>;
  inline std::vector<Lane> create_std__vector_Lane_(size_t size) noexcept {
    std::vector<Lane> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<LaneGuidance>
  /**
   * Specialized version of `std::optional<LaneGuidance>`.
   */
  using std__optional_LaneGuidance_ = std::optional<LaneGuidance>;
  inline std::optional<LaneGuidance> create_std__optional_LaneGuidance_(const LaneGuidance& value) noexcept {
    return std::optional<LaneGuidance>(value);
  }
  inline bool has_value_std__optional_LaneGuidance_(const std::optional<LaneGuidance>& optional) noexcept {
    return optional.has_value();
  }
  inline LaneGuidance get_std__optional_LaneGuidance_(const std::optional<LaneGuidance>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroManeuver>
  /**
   * Specialized version of `std::vector<NitroManeuver>`.
   */
  using std__vector_NitroManeuver_ = std::vector<NitroManeuver>;
  inline std::vector<NitroManeuver> create_std__vector_NitroManeuver_(size_t size) noexcept {
    std::vector<NitroManeuver> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<HybridHybridMapTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHybridMapTemplateSpec>`.
   */
  using std__shared_ptr_HybridHybridMapTemplateSpec_ = std::shared_ptr<HybridHybridMapTemplateSpec>;
  std::shared_ptr<HybridHybridMapTemplateSpec> create_std__shared_ptr_HybridHybridMapTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHybridMapTemplateSpec_(std__shared_ptr_HybridHybridMapTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHybridMapTemplateSpec>
  using std__weak_ptr_HybridHybridMapTemplateSpec_ = std::weak_ptr<HybridHybridMapTemplateSpec>;
  inline std__weak_ptr_HybridHybridMapTemplateSpec_ weakify_std__shared_ptr_HybridHybridMapTemplateSpec_(const std::shared_ptr<HybridHybridMapTemplateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridHybridMessageTemplateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHybridMessageTemplateSpec>`.
   */
  using std__shared_ptr_HybridHybridMessageTemplateSpec_ = std::shared_ptr<HybridHybridMessageTemplateSpec>;
  std::shared_ptr<HybridHybridMessageTemplateSpec> create_std__shared_ptr_HybridHybridMessageTemplateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHybridMessageTemplateSpec_(std__shared_ptr_HybridHybridMessageTemplateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHybridMessageTemplateSpec>
  using std__weak_ptr_HybridHybridMessageTemplateSpec_ = std::weak_ptr<HybridHybridMessageTemplateSpec>;
  inline std__weak_ptr_HybridHybridMessageTemplateSpec_ weakify_std__shared_ptr_HybridHybridMessageTemplateSpec_(const std::shared_ptr<HybridHybridMessageTemplateSpec>& strong) noexcept { return strong; }

} // namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid::bridge::swift
