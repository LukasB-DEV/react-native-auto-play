///
/// JNitroManeuver.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "NitroManeuver.hpp"

#include "AttributedInstructionVariant.hpp"
#include "AttributedInstructionVariantImage.hpp"
#include "AutoText.hpp"
#include "Distance.hpp"
#include "DistanceUnits.hpp"
#include "DurationWithTimeZone.hpp"
#include "ForkType.hpp"
#include "JAttributedInstructionVariant.hpp"
#include "JAttributedInstructionVariantImage.hpp"
#include "JAutoText.hpp"
#include "JDistance.hpp"
#include "JDistanceUnits.hpp"
#include "JDurationWithTimeZone.hpp"
#include "JForkType.hpp"
#include "JKeepType.hpp"
#include "JLane.hpp"
#include "JLaneGuidance.hpp"
#include "JLaneStatus.hpp"
#include "JManeuverType.hpp"
#include "JNitroImage.hpp"
#include "JOffRampType.hpp"
#include "JOnRampType.hpp"
#include "JTrafficSide.hpp"
#include "JTravelEstimates.hpp"
#include "JTurnType.hpp"
#include "KeepType.hpp"
#include "Lane.hpp"
#include "LaneGuidance.hpp"
#include "LaneStatus.hpp"
#include "ManeuverType.hpp"
#include "NitroImage.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "TrafficSide.hpp"
#include "TravelEstimates.hpp"
#include "TurnType.hpp"
#include <optional>
#include <string>
#include <vector>

namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "NitroManeuver" and the the Kotlin data class "NitroManeuver".
   */
  struct JNitroManeuver final: public jni::JavaClass<JNitroManeuver> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/at/g4rb4g3/autoplay/hybrid/NitroManeuver;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct NitroManeuver by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    NitroManeuver toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldAttributedInstructionVariants = clazz->getField<jni::JArrayClass<JAttributedInstructionVariant>>("attributedInstructionVariants");
      jni::local_ref<jni::JArrayClass<JAttributedInstructionVariant>> attributedInstructionVariants = this->getFieldValue(fieldAttributedInstructionVariants);
      static const auto fieldSymbolImage = clazz->getField<JNitroImage>("symbolImage");
      jni::local_ref<JNitroImage> symbolImage = this->getFieldValue(fieldSymbolImage);
      static const auto fieldJunctionImage = clazz->getField<JNitroImage>("junctionImage");
      jni::local_ref<JNitroImage> junctionImage = this->getFieldValue(fieldJunctionImage);
      static const auto fieldTurnType = clazz->getField<JTurnType>("turnType");
      jni::local_ref<JTurnType> turnType = this->getFieldValue(fieldTurnType);
      static const auto fieldAngle = clazz->getField<jni::JDouble>("angle");
      jni::local_ref<jni::JDouble> angle = this->getFieldValue(fieldAngle);
      static const auto fieldElementAngles = clazz->getField<jni::JArrayDouble>("elementAngles");
      jni::local_ref<jni::JArrayDouble> elementAngles = this->getFieldValue(fieldElementAngles);
      static const auto fieldExitNumber = clazz->getField<jni::JDouble>("exitNumber");
      jni::local_ref<jni::JDouble> exitNumber = this->getFieldValue(fieldExitNumber);
      static const auto fieldOffRampType = clazz->getField<JOffRampType>("offRampType");
      jni::local_ref<JOffRampType> offRampType = this->getFieldValue(fieldOffRampType);
      static const auto fieldOnRampType = clazz->getField<JOnRampType>("onRampType");
      jni::local_ref<JOnRampType> onRampType = this->getFieldValue(fieldOnRampType);
      static const auto fieldForkType = clazz->getField<JForkType>("forkType");
      jni::local_ref<JForkType> forkType = this->getFieldValue(fieldForkType);
      static const auto fieldKeepType = clazz->getField<JKeepType>("keepType");
      jni::local_ref<JKeepType> keepType = this->getFieldValue(fieldKeepType);
      static const auto fieldId = clazz->getField<jni::JString>("id");
      jni::local_ref<jni::JString> id = this->getFieldValue(fieldId);
      static const auto fieldTravelEstimates = clazz->getField<JTravelEstimates>("travelEstimates");
      jni::local_ref<JTravelEstimates> travelEstimates = this->getFieldValue(fieldTravelEstimates);
      static const auto fieldTrafficSide = clazz->getField<JTrafficSide>("trafficSide");
      jni::local_ref<JTrafficSide> trafficSide = this->getFieldValue(fieldTrafficSide);
      static const auto fieldLinkedLaneGuidance = clazz->getField<JLaneGuidance>("linkedLaneGuidance");
      jni::local_ref<JLaneGuidance> linkedLaneGuidance = this->getFieldValue(fieldLinkedLaneGuidance);
      static const auto fieldManeuverType = clazz->getField<JManeuverType>("maneuverType");
      jni::local_ref<JManeuverType> maneuverType = this->getFieldValue(fieldManeuverType);
      static const auto fieldRoadName = clazz->getField<jni::JArrayClass<jni::JString>>("roadName");
      jni::local_ref<jni::JArrayClass<jni::JString>> roadName = this->getFieldValue(fieldRoadName);
      static const auto fieldHighwayExitLabel = clazz->getField<jni::JString>("highwayExitLabel");
      jni::local_ref<jni::JString> highwayExitLabel = this->getFieldValue(fieldHighwayExitLabel);
      return NitroManeuver(
        [&]() {
          size_t __size = attributedInstructionVariants->size();
          std::vector<AttributedInstructionVariant> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = attributedInstructionVariants->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }(),
        symbolImage->toCpp(),
        junctionImage != nullptr ? std::make_optional(junctionImage->toCpp()) : std::nullopt,
        turnType != nullptr ? std::make_optional(turnType->toCpp()) : std::nullopt,
        angle != nullptr ? std::make_optional(angle->value()) : std::nullopt,
        elementAngles != nullptr ? std::make_optional([&]() {
          size_t __size = elementAngles->size();
          std::vector<double> __vector(__size);
          elementAngles->getRegion(0, __size, __vector.data());
          return __vector;
        }()) : std::nullopt,
        exitNumber != nullptr ? std::make_optional(exitNumber->value()) : std::nullopt,
        offRampType != nullptr ? std::make_optional(offRampType->toCpp()) : std::nullopt,
        onRampType != nullptr ? std::make_optional(onRampType->toCpp()) : std::nullopt,
        forkType != nullptr ? std::make_optional(forkType->toCpp()) : std::nullopt,
        keepType != nullptr ? std::make_optional(keepType->toCpp()) : std::nullopt,
        id->toStdString(),
        travelEstimates->toCpp(),
        trafficSide->toCpp(),
        linkedLaneGuidance != nullptr ? std::make_optional(linkedLaneGuidance->toCpp()) : std::nullopt,
        maneuverType->toCpp(),
        roadName != nullptr ? std::make_optional([&]() {
          size_t __size = roadName->size();
          std::vector<std::string> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = roadName->getElement(__i);
            __vector.push_back(__element->toStdString());
          }
          return __vector;
        }()) : std::nullopt,
        highwayExitLabel != nullptr ? std::make_optional(highwayExitLabel->toStdString()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JNitroManeuver::javaobject> fromCpp(const NitroManeuver& value) {
      return newInstance(
        [&]() {
          size_t __size = value.attributedInstructionVariants.size();
          jni::local_ref<jni::JArrayClass<JAttributedInstructionVariant>> __array = jni::JArrayClass<JAttributedInstructionVariant>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.attributedInstructionVariants[__i];
            __array->setElement(__i, *JAttributedInstructionVariant::fromCpp(__element));
          }
          return __array;
        }(),
        JNitroImage::fromCpp(value.symbolImage),
        value.junctionImage.has_value() ? JNitroImage::fromCpp(value.junctionImage.value()) : nullptr,
        value.turnType.has_value() ? JTurnType::fromCpp(value.turnType.value()) : nullptr,
        value.angle.has_value() ? jni::JDouble::valueOf(value.angle.value()) : nullptr,
        value.elementAngles.has_value() ? [&]() {
          size_t __size = value.elementAngles.value().size();
          jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
          __array->setRegion(0, __size, value.elementAngles.value().data());
          return __array;
        }() : nullptr,
        value.exitNumber.has_value() ? jni::JDouble::valueOf(value.exitNumber.value()) : nullptr,
        value.offRampType.has_value() ? JOffRampType::fromCpp(value.offRampType.value()) : nullptr,
        value.onRampType.has_value() ? JOnRampType::fromCpp(value.onRampType.value()) : nullptr,
        value.forkType.has_value() ? JForkType::fromCpp(value.forkType.value()) : nullptr,
        value.keepType.has_value() ? JKeepType::fromCpp(value.keepType.value()) : nullptr,
        jni::make_jstring(value.id),
        JTravelEstimates::fromCpp(value.travelEstimates),
        JTrafficSide::fromCpp(value.trafficSide),
        value.linkedLaneGuidance.has_value() ? JLaneGuidance::fromCpp(value.linkedLaneGuidance.value()) : nullptr,
        JManeuverType::fromCpp(value.maneuverType),
        value.roadName.has_value() ? [&]() {
          size_t __size = value.roadName.value().size();
          jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.roadName.value()[__i];
            __array->setElement(__i, *jni::make_jstring(__element));
          }
          return __array;
        }() : nullptr,
        value.highwayExitLabel.has_value() ? jni::make_jstring(value.highwayExitLabel.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::at::g4rb4g3::autoplay::hybrid
