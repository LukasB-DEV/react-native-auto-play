diff --git a/node_modules/react-native/React/CoreModules/RCTTiming.h b/node_modules/react-native/React/CoreModules/RCTTiming.h
index 2a7519a..6ce3811 100644
--- a/node_modules/react-native/React/CoreModules/RCTTiming.h
+++ b/node_modules/react-native/React/CoreModules/RCTTiming.h
@@ -22,7 +22,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 @end
 
-@interface RCTTiming : NSObject <RCTBridgeModule, RCTInvalidating, RCTFrameUpdateObserver, RCTInitializing>
+@interface RCTTiming : NSObject <RCTBridgeModule, RCTInvalidating, RCTInitializing>
 
 - (instancetype)initWithDelegate:(id<RCTTimingDelegate>)delegate;
 - (void)createTimerForNextFrame:(NSNumber *)callbackID
diff --git a/node_modules/react-native/React/CoreModules/RCTTiming.mm b/node_modules/react-native/React/CoreModules/RCTTiming.mm
index 0b36307..b504a5d 100644
--- a/node_modules/react-native/React/CoreModules/RCTTiming.mm
+++ b/node_modules/react-native/React/CoreModules/RCTTiming.mm
@@ -101,11 +101,10 @@ static const NSTimeInterval kIdleCallbackFrameDeadline = 0.001;
   BOOL _sendIdleEvents;
   BOOL _inBackground;
   id<RCTTimingDelegate> _timingDelegate;
+  NSTimer *_timer;
 }
 
 @synthesize bridge = _bridge;
-@synthesize paused = _paused;
-@synthesize pauseCallback = _pauseCallback;
 
 RCT_EXPORT_MODULE()
 
@@ -125,7 +124,6 @@ RCT_EXPORT_MODULE()
 
 - (void)setup
 {
-  _paused = YES;
   _timers = [NSMutableDictionary new];
   _inBackground = NO;
   RCTExecuteOnMainQueue(^{
@@ -136,6 +134,8 @@ RCT_EXPORT_MODULE()
     }
   });
 
+  _timer = [NSTimer scheduledTimerWithTimeInterval:kFrameDuration target:self selector:@selector(didUpdateFrame:) userInfo:Nil repeats:YES];
+
   for (NSString *name in @[
          UIApplicationWillResignActiveNotification,
          UIApplicationDidEnterBackgroundNotification,
@@ -172,15 +172,12 @@ RCT_EXPORT_MODULE()
 
 - (void)invalidate
 {
-  [self stopTimers];
   _bridge = nil;
   _timingDelegate = nil;
 }
 
 - (void)appDidMoveToBackground
 {
-  // Deactivate the CADisplayLink while in the background.
-  [self stopTimers];
   _inBackground = YES;
 
   // Issue one final timer callback, which will schedule a
@@ -191,7 +188,6 @@ RCT_EXPORT_MODULE()
 - (void)appDidMoveToForeground
 {
   _inBackground = NO;
-  [self startTimers];
 }
 
 - (void)proximityChanged
@@ -204,43 +200,12 @@ RCT_EXPORT_MODULE()
   }
 }
 
-- (void)stopTimers
+- (void)didUpdateFrame:(RCTFrameUpdate *)update
 {
   if (_inBackground) {
     return;
   }
 
-  if (!_paused) {
-    _paused = YES;
-    if (_pauseCallback) {
-      _pauseCallback();
-    }
-  }
-}
-
-- (void)startTimers
-{
-  if ((!_bridge && !_timingDelegate) || _inBackground || ![self hasPendingTimers]) {
-    return;
-  }
-
-  if (_paused) {
-    _paused = NO;
-    if (_pauseCallback) {
-      _pauseCallback();
-    }
-  }
-}
-
-- (BOOL)hasPendingTimers
-{
-  @synchronized(_timers) {
-    return _sendIdleEvents || _timers.count > 0;
-  }
-}
-
-- (void)didUpdateFrame:(RCTFrameUpdate *)update
-{
   NSDate *nextScheduledTarget = [NSDate distantFuture];
   NSMutableArray<_RCTTimer *> *timersToCall = [NSMutableArray new];
   NSDate *now = [NSDate date]; // compare all the timers to the same base time
@@ -289,58 +254,6 @@ RCT_EXPORT_MODULE()
       }
     }
   }
-
-  // Switch to a paused state only if we didn't call any timer this frame, so if
-  // in response to this timer another timer is scheduled, we don't pause and unpause
-  // the displaylink frivolously.
-  NSUInteger timerCount;
-  @synchronized(_timers) {
-    timerCount = _timers.count;
-  }
-  if (_inBackground) {
-    if (timerCount) {
-      [self scheduleSleepTimer:nextScheduledTarget];
-    }
-  } else if (!_sendIdleEvents && timersToCall.count == 0) {
-    // No need to call the pauseCallback as RCTDisplayLink will ask us about our paused
-    // status immediately after completing this call
-    if (timerCount == 0) {
-      _paused = YES;
-    }
-    // If the next timer is more than 1 second out, pause and schedule an NSTimer;
-    else if ([nextScheduledTarget timeIntervalSinceNow] > kMinimumSleepInterval) {
-      [self scheduleSleepTimer:nextScheduledTarget];
-      _paused = YES;
-    }
-  }
-}
-
-- (void)scheduleSleepTimer:(NSDate *)sleepTarget
-{
-  @synchronized(self) {
-    if (!_sleepTimer || !_sleepTimer.valid) {
-      _sleepTimer = [[NSTimer alloc] initWithFireDate:sleepTarget
-                                             interval:0
-                                               target:[_RCTTimingProxy proxyWithTarget:self]
-                                             selector:@selector(timerDidFire)
-                                             userInfo:nil
-                                              repeats:NO];
-      [[NSRunLoop currentRunLoop] addTimer:_sleepTimer forMode:NSDefaultRunLoopMode];
-    } else {
-      _sleepTimer.fireDate = [_sleepTimer.fireDate earlierDate:sleepTarget];
-    }
-  }
-}
-
-- (void)timerDidFire
-{
-  _sleepTimer = nil;
-  if (_paused) {
-    [self startTimers];
-
-    // Immediately dispatch frame, so we don't have to wait on the displaylink.
-    [self didUpdateFrame:nil];
-  }
 }
 
 /**
@@ -397,16 +310,6 @@ RCT_EXPORT_METHOD(createTimer
   @synchronized(_timers) {
     _timers[callbackID] = timer;
   }
-
-  if (_inBackground) {
-    [self scheduleSleepTimer:timer.target];
-  } else if (_paused) {
-    if ([timer.target timeIntervalSinceNow] > kMinimumSleepInterval) {
-      [self scheduleSleepTimer:timer.target];
-    } else {
-      [self startTimers];
-    }
-  }
 }
 
 RCT_EXPORT_METHOD(deleteTimer : (double)timerID)
@@ -414,19 +317,11 @@ RCT_EXPORT_METHOD(deleteTimer : (double)timerID)
   @synchronized(_timers) {
     [_timers removeObjectForKey:[NSNumber numberWithDouble:timerID]];
   }
-  if (![self hasPendingTimers]) {
-    [self stopTimers];
-  }
 }
 
 RCT_EXPORT_METHOD(setSendIdleEvents : (BOOL)sendIdleEvents)
 {
   _sendIdleEvents = sendIdleEvents;
-  if (sendIdleEvents) {
-    [self startTimers];
-  } else if (![self hasPendingTimers]) {
-    [self stopTimers];
-  }
 }
 
 @end
